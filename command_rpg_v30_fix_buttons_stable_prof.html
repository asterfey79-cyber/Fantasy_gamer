<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Command RPG v26 ‚Äî Tensura Saga (Worlds + Empire + Party)</title>
  <style>
    :root{
      --bg:#0f0f12;
      --panel: rgba(255,255,255,.07);
      --panel2: rgba(255,255,255,.10);
      --stroke: rgba(255,255,255,.14);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.68);
      --shadow: 0 18px 54px rgba(0,0,0,.45);
      --radius: 18px;
      --good: rgba(120,220,160,.95);
      --bad: rgba(255,92,122,.95);
      --warn: rgba(255,200,80,.95);
      --accent: rgba(175,180,185,.95);
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color: var(--text);
      background:
        radial-gradient(1200px 900px at 20% 10%, rgba(124,92,255,.22), transparent 55%),
        radial-gradient(900px 700px at 80% 30%, rgba(43,213,118,.15), transparent 60%),
        radial-gradient(800px 600px at 50% 90%, rgba(255,92,122,.10), transparent 55%),
        var(--bg);
      min-height:100vh;
    }
    .wrap{ max-width: 1240px; margin: 0 auto; padding: 14px 12px 30px; }
    header{
      display:flex; align-items:center; justify-content:space-between; gap:12px;
      margin-bottom: 12px;
    }
    .brand{ display:flex; align-items:center; gap:12px; user-select:none; min-width:0; }
    .logo{
      width:38px;height:38px;border-radius:14px;
      background: linear-gradient(135deg, rgba(124,92,255,.9), rgba(43,213,118,.85));
      box-shadow: var(--shadow);
      flex:0 0 auto;
    }
    .brandText{ min-width:0; }
    .brand h1{ font-size: 15px; margin:0; letter-spacing:.2px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .brand p{ margin:0; font-size:12px; color: var(--muted); white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }

    .grid{ display:grid; grid-template-columns: 1.55fr .95fr; gap: 12px; }
    @media (max-width: 980px){ .grid{ grid-template-columns: 1fr; } }

    .card{
      background: var(--panel);
      border: 1px solid var(--stroke);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(14px);
      overflow:hidden;
    }
    .cardHead{
      padding: 12px 12px 0;
      display:flex; align-items:center; justify-content:space-between; gap:12px;
    }
    .sectionTitle{
      margin: 0;
      font-size: 12px;
      color: var(--muted);
      letter-spacing: .6px;
      text-transform: uppercase;
    }
    .pillRow{ display:flex; flex-wrap:wrap; gap:8px; padding: 10px 12px 0; }
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding: 8px 10px; border-radius: 999px;
      background: var(--panel2); border: 1px solid var(--stroke);
      font-size: 12px; color: var(--muted);
      white-space:nowrap;
    }
    .pill b{ color: var(--text); font-weight:600; }

    .pane{ padding: 12px; }
    .story{
      white-space: pre-wrap;
      line-height: 1.6;
      color: var(--muted);
      font-size: 13px;
      min-height: 240px;
      max-height: 440px;
      overflow:auto;
      padding-right: 6px;
    }
    .help{
      color: rgba(255,255,255,.55);
      font-size: 12px;
      margin-top: 10px;
      line-height: 1.55;
    }

    /* Choices UI */
    .choicesWrap{
      margin-top: 10px;
      padding: 10px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
    }
    .choicesTop{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      margin-bottom: 8px;
    }
    .choicesTop .t{
      font-size: 12px; color: rgba(255,255,255,.62); letter-spacing:.4px;
      text-transform: uppercase;
    }
    .choicesRow{
      display:flex; flex-wrap:wrap; gap:8px;
    }
    .choiceBtn{
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.18);
      color: rgba(255,255,255,.86);
      cursor:pointer;
      transition: transform .08s ease, filter .12s ease, background .12s ease;
      font-weight: 750;
      font-size: 12px;
    }
    .choiceBtn:hover{ background: rgba(255,255,255,.10); transform: translateY(-1px); }
    .choiceBtn:active{ transform: translateY(0px) scale(.99); }
    .choiceBtn.good{ border-color: rgba(43,213,118,.22); background: rgba(43,213,118,.10); }
    .choiceBtn.bad{ border-color: rgba(255,92,122,.25); background: rgba(255,92,122,.10); }
    .choiceBtn.warn{ border-color: rgba(255,200,80,.25); background: rgba(255,200,80,.10); }

    .inputRow{
      display:flex; gap:10px; padding: 10px 12px 12px;
      border-top: 1px solid rgba(255,255,255,.10);
      align-items:center;
    }
    input{
      flex:1;
      padding: 12px 12px;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(0,0,0,.22);
      color: var(--text);
      outline:none;
    }
    .btn{
      padding: 11px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.07);
      color: var(--text);
      cursor:pointer;
      transition: transform .08s ease, filter .12s ease, background .12s ease;
      font-weight: 650;
      white-space:nowrap;
    }
    .btn:hover{ background: rgba(255,255,255,.10); transform: translateY(-1px); }
    .btn:active{ transform: translateY(0px) scale(.99); }
    .btnPrimary{
      background: linear-gradient(135deg, rgba(124,92,255,.92), rgba(43,213,118,.70));
      border-color: rgba(255,255,255,.18);
    }
    .btnPrimary:hover{ filter: brightness(1.05); }
    .btnDanger{
      background: rgba(255,92,122,.18);
      border-color: rgba(255,92,122,.35);
    }
    .btnDanger:hover{ background: rgba(255,92,122,.24); }
    .btn[disabled]{ opacity:.45; cursor:not-allowed; transform:none; }

    /* Battle */
    .battleUI{ display:none; border-top: 1px solid rgba(255,255,255,.10); }
    .battleBar{
      display:flex; gap:10px; flex-wrap:wrap;
      padding: 12px 12px 0;
    }
    .meter{
      flex: 1 1 260px;
      border:1px solid rgba(255,255,255,.12);
      border-radius: 16px;
      padding: 10px 10px;
      background: rgba(255,255,255,.05);
    }
    .meter .top{
      display:flex; justify-content:space-between; gap:10px;
      color: rgba(255,255,255,.70);
      font-size: 12px;
    }
    .barWrap{
      margin-top: 8px;
      height: 10px;
      border-radius: 999px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.08);
      overflow:hidden;
    }
    .barFill{ height:100%; width: 50%; background: var(--accent); }
    .barFill.bad{ background: var(--bad); }
    .barFill.good{ background: var(--good); }

    .skills{
      display:grid;
      grid-template-columns: repeat(2, minmax(0,1fr));
      gap:10px;
      padding: 12px 12px 12px;
    }
    @media (max-width: 520px){ .skills{ grid-template-columns: 1fr; } }

    /* Sidebar */
    .sidePad{ padding: 12px 12px 12px; }
    .twoCols{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; margin-top: 10px; }
    .box{
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
      border-radius: 16px;
      padding: 10px;
    }
    .k{ font-size: 12px; color: var(--muted); }
    .v{ margin-top: 6px; font-size: 16px; font-weight: 820; }
    .mini{ font-size: 12px; color: rgba(255,255,255,.60); line-height: 1.45; margin-top: 6px; }

    .log{
      margin-top: 10px;
      max-height: 320px;
      overflow:auto;
      display:grid; gap:10px;
      padding-right: 6px;
    }
    .logItem{
      padding: 10px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.14);
      color: var(--muted);
      font-size: 12px;
      line-height: 1.55;
    }
    .logItem b{ color: var(--text); }
    .logItem .t{ color: rgba(255,255,255,.40); font-size: 11px; margin-top: 6px; }

    /* Overlays / Modals */
    .overlay{
      position: fixed; inset:0;
      display:none;
      align-items:center; justify-content:center;
      background: rgba(0,0,0,.60);
      backdrop-filter: blur(10px);
      padding: 12px;
      z-index: 9999;
    }
    .modal{
      width:min(920px, 100%);
      border-radius: 22px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(15, 22, 40, .92);
      box-shadow: 0 40px 120px rgba(0,0,0,.65);
      overflow:hidden;
      max-height: 92vh;
      display:flex;
      flex-direction:column;
    }
    .modalTop{
      padding: 12px 12px 10px;
      border-bottom: 1px solid rgba(255,255,255,.10);
      display:flex; align-items:flex-start; justify-content:space-between; gap:12px;
    }
    .modalTop h2{ margin:0; font-size: 16px; }
    .modalTop p{ margin:6px 0 0; color: var(--muted); font-size: 12px; line-height:1.55; }
    .modalBody{
      padding: 12px 12px 12px;
      display:grid;
      grid-template-columns: 1.1fr .9fr;
      gap:10px;
      overflow:auto;
    }
    @media (max-width: 900px){
      .modalBody{ grid-template-columns: 1fr; }
      .brand p{ display:none; }
    }
    .field{
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
      border-radius: 16px;
      padding: 10px;
    }
    .field label{ display:block; font-size: 12px; color: var(--muted); }
    .field input, .field select{
      margin-top: 8px;
      width:100%;
      padding: 10px 12px;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.22);
      color: var(--text);
      outline:none;
    }
    .tagList{ display:flex; flex-wrap:wrap; gap:8px; margin-top: 10px; }
    .tag{
      padding: 7px 10px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.75);
      font-size: 12px;
    }
    .row{ display:flex; gap:10px; flex-wrap:wrap; justify-content:space-between; align-items:center; margin-top: 10px; }
    .list{ display:grid; gap:10px; margin-top:10px; }
    .listItem{
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
      border-radius: 16px;
      padding: 10px;
      display:flex; gap:10px; align-items:flex-start; justify-content:space-between;
    }
    .listItem .left{ min-width:0; }
    .listItem .name{ font-weight:800; font-size: 13px; }
    .listItem .desc{ margin-top:4px; color: rgba(255,255,255,.60); font-size: 12px; line-height: 1.45; }
    .rar{
      display:inline-flex;
      padding: 2px 8px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.18);
      color: rgba(255,255,255,.72);
      font-size: 11px;
      margin-left: 6px;
      vertical-align: middle;
    }
    .rar.legendary{ border-color: rgba(255,215,0,.35); background: rgba(255,215,0,.12); }
    .rar.legend{ border-color: rgba(255,92,122,.30); background: rgba(255,92,122,.10); }
    .rar.rare{ border-color: rgba(124,92,255,.30); background: rgba(124,92,255,.10); }
    .rar.common{ border-color: rgba(255,255,255,.16); background: rgba(255,255,255,.06); }
    .rar.trash{ border-color: rgba(180,180,180,.18); background: rgba(180,180,180,.06); }

    /* Gacha Animation */
    .gachaBox{ padding: 20px 14px 14px; text-align:center; }
    .spinner{
      width: 88px; height: 88px; border-radius: 26px;
      margin: 0 auto 14px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      position: relative;
      overflow:hidden;
      box-shadow: 0 20px 70px rgba(0,0,0,.35);
    }
    .spinner::before{
      content:"";
      position:absolute; inset:-40%;
      background: conic-gradient(from 0deg, rgba(124,92,255,.0), rgba(124,92,255,.85), rgba(43,213,118,.85), rgba(255,92,122,.85), rgba(124,92,255,.0));
      animation: spin 1s linear infinite;
    }
    .spinner::after{
      content:"";
      position:absolute; inset:10px;
      border-radius: 18px;
      background: rgba(15, 22, 40, .92);
      border: 1px solid rgba(255,255,255,.12);
    }
    @keyframes spin{ to{ transform: rotate(360deg); } }
    .reveal{
      margin-top: 10px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
      border-radius: 16px;
      padding: 12px;
      text-align:left;
    }
    .reveal .big{ font-weight: 900; font-size: 15px; letter-spacing:.2px; }
    .reveal .small{ margin-top: 6px; color: rgba(255,255,255,.62); font-size: 12px; line-height: 1.5; }
  
    /* ===== v7 additions ===== */
    .inputRow{ display:none !important; } /* commands replaced by buttons */
    .menuBtn{
      position: fixed;
      right: 14px;
      bottom: 14px;
      z-index: 9998;
      border-radius: 16px;
      padding: 12px 14px;
      border: 1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.10);
      color: rgba(255,255,255,.92);
      font-weight: 900;
      box-shadow: var(--shadow);
      backdrop-filter: blur(14px);
      cursor:pointer;
    }
    .menuBtn:active{ transform: scale(.99); }
    .menuGrid{
      display:grid;
      grid-template-columns: repeat(2, minmax(0,1fr));
      gap:10px;
      margin-top: 10px;
    }
    @media (max-width: 560px){
      .menuGrid{ grid-template-columns: 1fr 1fr; }
    }
    .menuCard{
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      border-radius: 18px;
      padding: 12px;
      cursor:pointer;
      transition: transform .08s ease, background .12s ease;
      min-height: 58px;
    }
    .menuCard:hover{ background: rgba(255,255,255,.10); transform: translateY(-1px); }
    .menuCard .t{ font-weight: 950; }
    .menuCard .d{ margin-top:6px; color: rgba(255,255,255,.62); font-size: 12px; line-height:1.4; }
    .battleAnimLayer{
      position: relative;
      overflow:hidden;
      border-radius: 18px;
    }
    .fxSlash{
      position:absolute;
      left:-40%;
      top: -30%;
      width: 180%;
      height: 160%;
      background: linear-gradient(90deg, rgba(255,255,255,0), rgba(255,255,255,.18), rgba(255,255,255,0));
      transform: rotate(-18deg);
      opacity:0;
      pointer-events:none;
      z-index: 5;
    }
    .fxSlash.play{ animation: slash 420ms ease-out 1; }
    @keyframes slash{
      0%{ transform: translateX(-20%) rotate(-18deg); opacity:0; }
      25%{ opacity:1; }
      100%{ transform: translateX(20%) rotate(-18deg); opacity:0; }
    }
    .shake{ animation: shake .22s ease-in-out 1; }
    @keyframes shake{
      0%{ transform: translateX(0); }
      25%{ transform: translateX(-3px); }
      50%{ transform: translateX(3px); }
      75%{ transform: translateX(-2px); }
      100%{ transform: translateX(0); }
    }

  
  /* Cinematic battle scene */
  .cinematic{
    position:fixed; inset:0; display:none; align-items:center; justify-content:center;
    background: radial-gradient(circle at 50% 40%, rgba(255,255,255,0.08), rgba(0,0,0,0.78));
    z-index: 80;
  }
  .cinBox{
    width:min(520px, 92vw);
    border-radius: 18px;
    padding: 18px 16px;
    background: rgba(20,20,24,0.78);
    border: 1px solid rgba(255,255,255,0.16);
    box-shadow: 0 18px 60px rgba(0,0,0,0.55);
    text-align:center;
    animation: cinPop 0.9s ease both;
  }
  .cinTitle{ font-size: 20px; letter-spacing: 0.12em; font-weight: 800; text-transform: uppercase; }
  .cinSub{ margin-top: 8px; font-size: 13px; opacity: 0.9; }
  @keyframes cinPop{ 0%{transform:translateY(12px) scale(0.98); opacity:0} 40%{opacity:1} 100%{transform:translateY(0) scale(1);} }

</style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="brand">
        <div class="logo"></div>
        <div class="brandText">
          <h1>Command RPG v24</h1>
          <p>Tensura Pack ‚Ä¢ Choices UI ‚Ä¢ NPC random events t·ªët/x·∫•u ‚Ä¢ Talk c√≥ th·ªÉ b·ªã l·ª´a (-50% v√†ng) ‚Ä¢ Money c√≥ th·ªÉ b·ªã qu·ªµt l∆∞∆°ng</p>
        </div>
      </div>
      <div style="display:flex; gap:10px; align-items:center;">
        <button class="btn btnDanger" id="btnReset" style="display:none;">Ch∆°i l·∫°i</button>
      </div>
    </header>

    <div class="grid">
      <section class="card">
        <div class="cardHead">
          <p class="sectionTitle">C·ªët truy·ªán & L·ªánh</p>
          <span class="sectionTitle" id="statusLine">ch∆∞a b·∫Øt ƒë·∫ßu</span>
        </div>
        <div class="pillRow" id="hud"></div>

        <div class="pane">
          <div class="story" id="story"></div>

          <div class="choicesWrap" id="choicesWrap">
            <div class="choicesTop">
              <div class="t" id="choicesTitle">g·ª£i √Ω h√†nh ƒë·ªông</div>
              <div class="t" id="choicesHint">b·∫•m ƒë·ªÉ ch·∫°y l·ªánh</div>
            </div>
            <div class="choicesRow" id="choicesRow"></div>
          </div>

          <div class="help" id="help"></div>
        </div>

        <div class="battleUI" id="battleUI"><div class="fxSlash" id="fxSlash"></div>
          <div class="battleBar" id="battleBar"></div>
          <div class="skills" id="skills"></div>
        </div>

        <div class="inputRow">
          <input id="cmd" placeholder="Nh·∫≠p l·ªánh‚Ä¶ help | battle | talk | shop | money | gacha | forge | dungeon | trial | next" />
          <button class="btn btnPrimary" id="send">G·ª≠i</button>
        </div>
      </section>

      <aside class="card sidePad">
        <p class="sectionTitle">Tr·∫°ng th√°i</p>
        <div class="twoCols">
          <div class="box">
            <div class="k">Level</div>
            <div class="v" id="lv">-</div>
            <div class="mini" id="xp">EXP: -</div>
          </div>
          <div class="box">
            <div class="k">Tu·ªïi</div>
            <div class="v" id="age">-</div>
            <div class="mini">+1 tu·ªïi m·ªói <b>turn</b> (10 h√†nh ƒë·ªông). 100 tu·ªïi ‚Üí ch·∫øt gi√†.</div>
          </div>
          <div class="box">
            <div class="k">V√†ng</div>
            <div class="v" id="gold">-</div>
            <div class="mini">Talk c√≥ th·ªÉ b·ªã l·ª´a (-50% v√†ng).</div>
          </div>
          <div class="box">
            <div class="k">Souls</div>
            <div class="v" id="souls">-</div>
            <div class="mini">Linh h·ªìn t√≠ch lu·ªπ (d√πng cho ti·∫øn ho√° / ƒë·∫ø ch·∫ø).</div>
          </div>
          <div class="box">
            <div class="k">Ch·ªßng t·ªôc</div>
            <div class="v" id="race">-</div>
            <div class="mini" id="raceBonus">-</div>
          </div>
          <div class="box">
            <div class="k">Ch·ª©c nghi·ªáp</div>
            <div class="v" id="job">-</div>
            <div class="mini" id="jobBonus">-</div>
          </div>
          <div class="box">
            <div class="k">Ultimate</div>
            <div class="v" id="ultimate">-</div>
            <div class="mini" id="ultimateDesc">-</div>
          </div>
          <div class="box">
            <div class="k">Ph∆∞·ªõc l√†nh</div>
            <div class="v" id="blessCount">0</div>
            <div class="mini">Trial: 10 t·∫ßng/1 ph∆∞·ªõc. Dungeon: S·ª© gi·∫£ drop ph∆∞·ªõc.</div>
          </div>
          <div class="box">
            <div class="k">Shop Level</div>
            <div class="v" id="shopLevel">0</div>
            <div class="mini">Tip ƒë·ªÉ tƒÉng h√†ng hi·∫øm.</div>
          </div>
          <div class="box">
            <div class="k">Th·ªÉ l·ª±c</div>
            <div class="v" id="stamina">10/10</div>
            <div class="mini" id="staminaHint">Ti√™u hao theo h√†nh ƒë·ªông.</div>
          </div>
          <div class="box">
            <div class="k">Turn</div>
            <div class="v" id="turn">0</div>
            <div class="mini" id="ap">H√†nh ƒë·ªông: 0/10</div>
          </div>
          <div class="box">
            <div class="k">Ch·∫ø ƒë·ªô</div>
            <div class="v" id="mode">Free</div>
            <div class="mini" id="modeHint">-</div>
          </div>
        </div>

        <div style="margin-top:12px;">
          <p class="sectionTitle">Nh·∫≠t k√Ω</p>
          <div class="log" id="log"></div>
        </div>
      </aside>
    </div>
  </div>

  <div class="overlay" id="overlayCreate">
    <div class="modal">
      <div class="modalTop">
        <div>
          <h2>T·∫°o nh√¢n v·∫≠t (g·ªçn cho ƒëi·ªán tho·∫°i)</h2>
          <p>
            Ch·ªßng t·ªôc reroll <b>3 l·∫ßn</b> (sau ƒë√≥ kh√≥a). Ch·ª©c nghi·ªáp & Ultimate random theo ƒë·ªô hi·∫øm.
            <br/>Thua battle ‚Üí <b>kh·ªüi ƒë·ªông l·∫°i game</b>.
          </p>
        </div>
        <div style="display:flex; gap:10px;">
          <button class="btn" id="btnRerollAll">Random l·∫°i</button>
          <button class="btn btnPrimary" id="btnStart">B·∫Øt ƒë·∫ßu</button>
        </div>
      </div>
      <div class="modalBody">
        <div class="field">
          <label>T√™n</label>
          <input id="nameInput" maxlength="24" placeholder="V√≠ d·ª•: Aster" />
          <div class="row">
            <span class="tag" id="tagAge">Tu·ªïi: -</span>
            <span class="tag" id="tagLocation">N∆°i: -</span>
            <span class="tag" id="tagNPC">NPC: -</span>
          </div>

          <div class="row" style="margin-top:12px;">
            <div style="flex:1;">
              <label>Ch·ªßng t·ªôc (kh√≥a sau khi start)</label>
              <div class="row" style="margin-top:8px;">
                <span class="tag" id="raceTag">-</span>
                <button class="btn" id="btnRerollRace">Reroll t·ªôc (3)</button>
              </div>
              <div class="mini" id="racePerk">-</div>
            </div>
            <div style="flex:1;">
              <label>Ch·ª©c nghi·ªáp (random)</label>
              <div class="row" style="margin-top:8px;">
                <span class="tag" id="jobTag">-</span>
              </div>
              <div class="mini" id="jobPerk">-</div>
            </div>
          </div>

          <div style="margin-top:12px;">
            <label>Ultimate (random 1 l·∫ßn)</label>
            <div class="row" style="margin-top:8px;">
              <span class="tag" id="ultTag">-</span>
            </div>
            <div class="mini" id="ultPerk">-</div>
          </div>

          <div class="tagList" id="bonusTags"></div>
        </div>

        <div class="field">
          <label>Stat (random)</label>
          <div class="twoCols" style="margin-top:10px;">
            <div class="box"><div class="k">HP</div><div class="v" id="stHP">-</div></div>
            <div class="box"><div class="k">MP</div><div class="v" id="stMP">-</div></div>
            <div class="box"><div class="k">STR</div><div class="v" id="stSTR">-</div></div>
            <div class="box"><div class="k">DEX</div><div class="v" id="stDEX">-</div></div>
            <div class="box"><div class="k">INT</div><div class="v" id="stINT">-</div></div>
            <div class="box"><div class="k">CHA</div><div class="v" id="stCHA">-</div></div>
            <div class="box"><div class="k">LUK</div><div class="v" id="stLUK">-</div></div>
            <div class="box"><div class="k">DEF</div><div class="v" id="stDEF">-</div></div>
          </div>
          <div class="mini" style="margin-top:10px;">
            L·ªánh: <b>help</b>, <b>battle</b>, <b>dungeon</b>, <b>trial</b>, <b>shop</b>, <b>money</b>, <b>gacha</b>, <b>forge</b>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="overlay" id="overlayShop">
    <div class="modal">
      <div class="modalTop">
        <div>
          <h2>Shop (tip ƒë·ªÉ l√™n c·∫•p)</h2>
          <p>Mua ƒë·ªì h·ªìi ph·ª•c / v≈© kh√≠ / gi√°p. Tip cho ch·ªß qu√°n ƒë·ªÉ shop l√™n level v√† xu·∫•t hi·ªán h√†ng hi·∫øm h∆°n.</p>
        </div>
        <div style="display:flex; gap:10px;">
          <button class="btn" id="btnTipShop">Tip</button>
          <button class="btn btnPrimary" id="btnCloseShop">ƒê√≥ng</button>
        </div>
      </div>
      <div class="modalBody">
        <div class="field">
          <label>Ch·ªß qu√°n</label>
          <div class="mini" id="shopkeeperLine">-</div>
          <div class="tagList">
            <span class="tag" id="shopLevelTag">Shop level: 0</span>
            <span class="tag" id="shopTipCostTag">Tip cost: -</span>
          </div>
        </div>
        <div class="field">
          <label>H√†ng ƒëang b√°n</label>
          <div class="list" id="shopList"></div>
        </div>
      </div>
    </div>
  </div>

  <div class="overlay" id="overlayForge">
    <div class="modal">
      <div class="modalTop">
        <div>
          <h2>R√®n ƒë·ªì (+1 ƒë·∫øn +100)</h2>
          <p>Chance th√†nh c√¥ng: <b>1 / 10^n</b> v·ªõi n l√† c·∫•p n√¢ng ti·∫øp theo.</p>
        </div>
        <div style="display:flex; gap:10px;">
          <button class="btn btnPrimary" id="btnCloseForge">ƒê√≥ng</button>
        </div>
      </div>
      <div class="modalBody">
        <div class="field">
          <label>Ch·ªçn trang b·ªã ƒë·ªÉ r√®n</label>
          <div class="list" id="forgeList"></div>
        </div>
        <div class="field">
          <label>Chi ti·∫øt n√¢ng c·∫•p</label>
          <div class="mini" id="forgeDetail">Ch·ªçn m·ªôt trang b·ªã.</div>
          <div class="row">
            <button class="btn btnPrimary" id="btnForgeDo" disabled>N√¢ng c·∫•p</button>
            <button class="btn" id="btnForgeRefresh">L√†m m·ªõi</button>
          </div>
          <div class="mini" id="forgeHint" style="margin-top:10px;"></div>
        </div>
      </div>
    </div>
  </div>

  
  <div class="overlay" id="overlayTrial">
    <div class="modal">
      <div class="modalTop">
        <div>
          <h2>Trial (Th·∫ßn Linh + Anh H√πng)</h2>
          <p>G·ªôp <b>Trial Th·∫ßn</b> (50 t·∫ßng) v√† <b>Trial Anh H√πng</b> (100 t·∫ßng) v√†o chung m·ªôt menu.</p>
        </div>
        <div style="display:flex; gap:10px;">
          <button class="btn btnPrimary" id="btnCloseTrial">ƒê√≥ng</button>
        </div>
      </div>
      <div class="modalBody">
        <div class="field">
          <label>Ch·ªçn lo·∫°i Trial</label>
          <select id="trialModeSelect">
            <option value="god">Trial Th·∫ßn Linh (50 t·∫ßng)</option>
            <option value="hero">Trial Anh H√πng (100 t·∫ßng)</option>
          </select>

          <div id="trialGodBlock" style="margin-top:10px;">
            <label>Ch·ªçn th·∫ßn linh</label>
            <select id="trialSelect"></select>
            <div class="tagList" id="trialTags"></div>
            <div class="mini" id="trialProgress">-</div>
            <div class="mini">Nh·∫≠n ph∆∞·ªõc l√†nh khi v∆∞·ª£t <b>m·ªói 10 t·∫ßng</b>. (10/20/30/40/50)</div>
          </div>

          <div id="trialHeroBlock" style="margin-top:10px; display:none;">
            <div class="tagList" id="heroTrialTags"></div>
            <div class="mini" id="heroTrialProgress">-</div>
            <div class="mini">Qu√°i m·ªói t·∫ßng <b>Lv99</b>. V∆∞·ª£t 100 t·∫ßng nh·∫≠n <b>Ph∆∞·ªõc L√†nh Anh H√πng</b> + <b>Th√°nh Ki·∫øm</b> + <b>Th√°nh Gi√°p</b>.</div>
          </div>

          <div class="row" style="margin-top:10px;">
            <button class="btn btnPrimary" id="btnStartTrial">B·∫Øt ƒë·∫ßu / Ti·∫øp t·ª•c</button>
          </div>
          <div class="mini">Trong trial, th·∫Øng 1 t·∫ßng xong b·∫•m <b>Next</b> ƒë·ªÉ v√†o t·∫ßng ti·∫øp theo.</div>
        </div>
      </div>
    </div>
  </div>
  <!-- Gamble Overlay -->
  <div class="overlay" id="overlayGamble">
    <div class="modal" style="width:min(560px,100%);">
      <div class="modalTop">
        <div>
          <h2>Gamble (Ch·∫µn / L·∫ª)</h2>
          <p class="mini">Ch·ªçn ti·ªÅn c·ªçc + ch·ªçn <b>Ch·∫µn</b> ho·∫∑c <b>L·∫ª</b>. Tr√∫ng: nh·∫≠n <b>x10</b> ti·ªÅn c·ªçc ‚Ä¢ Tr∆∞·ª£t: m·∫•t <b>70%</b> ti·ªÅn c·ªçc.</p>
        </div>
        <div style="display:flex; gap:10px;">
          <button class="btn btnPrimary" id="btnCloseGamble">ƒê√≥ng</button>
        </div>
      </div>
      <div class="modalBody">
        <div class="field">
          <label>S·ªë ti·ªÅn c·ªçc</label>
          <input id="gambleBet" type="number" min="1" step="1" placeholder="Nh·∫≠p s·ªë v√†ng c·ªçc..." />
          <div class="row" style="margin-top:10px; gap:10px; flex-wrap:wrap;">
            <button class="btn" id="btnGambleEven">Ch·∫µn</button>
            <button class="btn" id="btnGambleOdd">L·∫ª</button>
            <span class="tag" id="gambleChoiceTag">(ch∆∞a ch·ªçn)</span>
          </div>
          <div class="row" style="margin-top:10px;">
            <button class="btn btnPrimary" id="btnGambleRoll">Quay</button>
          </div>
          <div class="gachaAnim" style="margin-top:12px;">
            <div class="gachaBox" id="gambleAnimBox">
              <div class="gachaGlow"></div>
              <div class="gachaText" id="gambleAnimText">READY</div>
            </div>
          </div>
          <div class="mini" id="gambleResult"></div>
        </div>
      </div>
    </div>
  </div>
  </div>

</div>
  </div>

    <!-- Empire Overlay -->
  <div class="overlay" id="overlayEmpire">
    <div class="modal" style="width:min(720px,100%);">
      <div class="modalTop">
        <div>
          <h2>ƒê·∫ø ch·∫ø (Tensura)</h2>
          <p class="mini">X√¢y d·ª±ng, n√¢ng c·∫•p v√† m·ªü slot ƒë·ªìng ƒë·ªôi.</p>
        </div>
        <div style="display:flex; gap:10px;">
          <button class="btn btnPrimary" id="btnCloseEmpire">ƒê√≥ng</button>
        </div>
      </div>
      <div class="modalBody">
        <div class="row" style="gap:10px; flex-wrap:wrap; align-items:flex-start;">
          <div class="box" style="flex:1; min-width:260px;">
            <div class="k">T·ªïng quan</div>
            <div class="mini" id="empireSummary">-</div>
            <div class="row" style="margin-top:10px; gap:10px; flex-wrap:wrap;">
              <button class="btn btnPrimary" id="btnEmpireCollect">Thu thu·∫ø</button>
              <button class="btn" id="btnOpenParty">Qu·∫£n l√Ω ƒë·ªìng ƒë·ªôi</button>
            </div>
            <div class="mini" style="margin-top:10px;">Thu·∫ø ph·ª• thu·ªôc <b>Ch·ª£</b> v√† <b>D√¢n s·ªë</b>.</div>
          </div>
          <div class="box" style="flex:1; min-width:260px;">
            <div class="k">C√¥ng tr√¨nh</div>
            <div id="empireBuildings" class="mini">-</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Party Overlay -->
  <div class="overlay" id="overlayParty">
    <div class="modal" style="width:min(720px,100%);">
      <div class="modalTop">
        <div>
          <h2>ƒê·ªìng ƒë·ªôi</h2>
          <p class="mini">ƒê·ªìng ƒë·ªôi s·∫Ω t·ª± ƒë·ªông h·ªó tr·ª£ ƒë√°nh trong chi·∫øn ƒë·∫•u.</p>
        </div>
        <div style="display:flex; gap:10px;">
          <button class="btn btnPrimary" id="btnCloseParty">ƒê√≥ng</button>
        </div>
      </div>
      <div class="modalBody">
        <div class="mini" id="partySummary">-</div>
        <div id="partyList" style="margin-top:10px; display:flex; flex-direction:column; gap:8px;"></div>
      </div>
    </div>
  </div>

  <!-- Recruit Overlay -->
  <div class="overlay" id="overlayRecruit">
    <div class="modal" style="width:min(560px,100%);">
      <div class="modalTop">
        <div>
          <h2>ƒê·∫∑t t√™n & Thu ph·ª•c</h2>
          <p class="mini">Sau khi ƒë√°nh b·∫°i qu√°i, b·∫°n c√≥ th·ªÉ thu ph·ª•c l√†m ƒë·ªìng ƒë·ªôi.</p>
        </div>
        <div style="display:flex; gap:10px;">
          <button class="btn btnPrimary" id="btnCloseRecruit">ƒê√≥ng</button>
        </div>
      </div>
      <div class="modalBody">
        <div class="mini" id="recruitInfo">-</div>
        <div class="field" style="margin-top:10px;">
          <label>T√™n ƒë·ªìng ƒë·ªôi</label>
          <input id="recruitName" placeholder="Nh·∫≠p t√™n..." />
        </div>
        <div class="row" style="margin-top:10px; gap:10px; flex-wrap:wrap;">
          <button class="btn btnPrimary" id="btnRecruitConfirm">Thu ph·ª•c</button>
          <span class="tag" id="recruitCostTag">Cost: 50 v√†ng + 5 Souls</span>
        </div>
        <div class="mini" id="recruitResult" style="margin-top:10px;"></div>
      </div>
    </div>
  </div>

<div class="overlay" id="overlayGacha">
    <div class="modal" style="width:min(560px,100%);">
      <div class="modalTop">
        <div>
          <h2>Gacha (100 v√†ng)</h2>
          <p>Legendary 0.1% ‚Ä¢ Legend 1% ‚Ä¢ Rare 3% ‚Ä¢ Common 15.9% ‚Ä¢ Trash 80%</p>
        </div>
        <div style="display:flex; gap:10px;">
          <button class="btn btnPrimary" id="btnCloseGacha">ƒê√≥ng</button>
        </div>
      </div>
      <div class="gachaBox">
        <div class="spinner"></div>
        <div class="mini" id="gachaStatus">ƒêang chu·∫©n b·ªã‚Ä¶</div>
        <div class="reveal" id="gachaReveal" style="display:none;"></div>
        <div class="row" style="justify-content:center; gap:10px; margin-top: 14px;">
          <button class="btn" id="btnGacha1">Gacha x1</button>
          <button class="btn" id="btnGacha10">Gacha x10</button>
          <button class="btn btnPrimary" id="btnGachaOk" style="display:none;">OK</button>
        </div>
      </div>
    </div>
  </div>

<script>

window.addEventListener("DOMContentLoaded", () => {
  /** ===================== Utilities ===================== **/
  const randInt = (min, max) => Math.floor(Math.random()*(max-min+1))+min;
  const clamp = (x,a,b) => Math.max(a, Math.min(b, x));
  const escapeHtml = (s)=> String(s).replace(/[&<>"\']/g, (c)=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","\'":"&#39;"}[c]));
  const pick = (arr) => arr[Math.floor(Math.random()*arr.length)];
  const nowTag = () => new Date().toLocaleTimeString([], {hour:"2-digit", minute:"2-digit"});
  const uid = () => (Math.random().toString(16).slice(2) + Date.now().toString(16)).slice(0, 16);

  function normalize(s){
    return (s||"")
      .toLowerCase()
      .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
      .replace(/[^a-z0-9\s]/g, " ")
      .replace(/\s+/g, " ")
      .trim();
  }

  function succeedTenPow(n){
    for(let i=0;i<n;i++){
      if(randInt(0,9) !== 0) return false;
    }
    return true;
  }

  const LOCATIONS = [
    "Th√†nh ph·ªë ƒê·∫°o T·∫∑c",
    "H·∫ßm M·ªè",
    "Ch·ª£ ƒê√™m",
    "Tensura",
    "Kamen Rider World",
    "Super Sentai World",
    "Black Clover World"
  ];

  /** =====================   /** ===================== Location Effects (Apocalypse) ===================== **/
  const LOCATION_EFFECTS = [
    { key:"Th√†nh Ph·ªë ƒê·∫°o T·∫∑c", match:(name)=>/th√†nh\s*ph·ªë\s*ƒë·∫°o\s*t·∫∑c|ƒë·∫°o\s*t·∫∑c/i.test(name), onEnter:(p)=>{
        p.stamina = Math.max(0, p.stamina - 8);
        addLog("üè¥ B·∫°n b∆∞·ªõc v√†o <b>Th√†nh Ph·ªë ƒê·∫°o T·∫∑c</b>. Kh√¥ng kh√≠ ƒë·∫ßy nguy hi·ªÉm...");
      },
      onTurn:(p)=>{
        if(p.inv && p.inv.length>0 && Math.random()<0.40){
          const idx = randInt(0, p.inv.length-1);
          const lost = p.inv.splice(idx,1)[0];
          addLog(`üè¥ B·ªã c∆∞·ªõp kho: m·∫•t <b>${itemMeta(lost.id).name}</b>!`);
          pushStory(`B·∫°n b·ªã c∆∞·ªõp: m·∫•t <b>${itemMeta(lost.id).name}</b> trong kho.`);
          if(p.equipped.weaponUid===lost.uid) p.equipped.weaponUid=null;
          if(p.equipped.armorUid===lost.uid) p.equipped.armorUid=null;
        }
      }
    },

    { key:"H·∫ßm M·ªè", match:(name)=>/h·∫ßm\s*m·ªè/i.test(name), onEnter:(p)=>{
        if(Math.random() < 0.70){
          p.forcedLaborTurns = 2;
          p.gold = 0;
          pushStory("‚õèÔ∏è B·∫°n v·ª´a b∆∞·ªõc v√†o h·∫ßm m·ªè th√¨ b·ªã b·∫Øt ƒëi l√†m <b>n√¥ d·ªãch</b>! (2 turn)\nTrong th·ªùi gian n√†y: v√†ng b·ªã t·ªãch thu v·ªÅ 0 m·ªói turn, th·ªÉ l·ª±c hao g·∫•p ƒë√¥i, ch·ªâ ƒë∆∞·ª£c <b>ki·∫øm ti·ªÅn</b>.");
          addLog("‚õèÔ∏è B·ªã b·∫Øt l√†m n√¥ d·ªãch trong h·∫ßm m·ªè (2 turn).");
        } else {
          addLog("‚õèÔ∏è H·∫ßm m·ªè u √°m‚Ä¶ nh∆∞ng b·∫°n may m·∫Øn kh√¥ng b·ªã b·∫Øt.");
        }
      }
    },

    { key:"Ch·ª£ ƒê√™m", match:(name)=>/ch·ª£\s*ƒë√™m/i.test(name), onEnter:(p)=>{
        if(!p.kidneyDebuff && Math.random() < 0.20){
          p.kidneyDebuff = true;
          pushStory("ü©∏ B·∫°n b·ªã b·∫Øt l√©n ƒëem ƒëi <b>m·ªï th·∫≠n</b> ·ªü Ch·ª£ ƒê√™m!\nGi·ªõi h·∫°n <b>m√°u</b> v√† <b>th·ªÉ l·ª±c</b> gi·∫£m <b>30%</b> (vƒ©nh vi·ªÖn).");
          addLog("ü©∏ Ch·ª£ ƒê√™m: b·ªã m·ªï th·∫≠n (-30% Max HP/STA).");
          computeStats(false);
        } else {
          addLog("üåô Ch·ª£ ƒê√™m ƒë√¥ng ƒë√∫c, nguy hi·ªÉm r√¨nh r·∫≠p.");
        }
      }
    },

    { key:"Tensura", match:(name)=>/tensura|tempest|slime/i.test(name), onEnter:(p)=>{
        p.stamina = Math.max(0, p.stamina - 5);
        if(Math.random() < 0.25){
          const mpLoss = Math.max(1, Math.floor(p.max.MP * 0.12));
          p.stats.MP = clamp(p.stats.MP - mpLoss, 0, p.max.MP);
          addLog("üü¶ Tensura: ma l·ª±c d√†y ƒë·∫∑c h√∫t <b>-12% MP</b> hi·ªán t·∫°i.");
        } else {
          addLog("üü¶ Tensura: kh√≠ ma l·ª±c n·∫∑ng n·ªÅ (-5 th·ªÉ l·ª±c).");
        }
      }
    },

    { key:"Kamen Rider World", match:(name)=>/kamen\s*rider/i.test(name), onEnter:(p)=>{
        p.stamina = Math.max(0, p.stamina - 6);
        if(p.gold>0 && Math.random() < 0.30){
          const fee = Math.max(1, Math.floor(p.gold * 0.15));
          p.gold = Math.max(0, p.gold - fee);
          addLog(`üõ°Ô∏è Kamen Rider World: ph√≠ chi·∫øn s·ª± <b>-${fee} v√†ng</b>.`);
        } else {
          addLog("üõ°Ô∏è Kamen Rider World: bi·∫øn ƒë·ªông d·ªìn d·∫≠p (-6 th·ªÉ l·ª±c).");
        }
      }
    },

    { key:"Super Sentai World", match:(name)=>/super\s*sentai|sentai/i.test(name), onEnter:(p)=>{
        p.stamina = Math.max(0, p.stamina - 6);
        if(p.inv && p.inv.length>0 && Math.random() < 0.20){
          const idx = randInt(0, p.inv.length-1);
          const lost = p.inv.splice(idx,1)[0];
          addLog(`üö® Super Sentai World: b·ªã n·ªï lan m·∫•t <b>${itemMeta(lost.id).name}</b>.`);
          pushStory(`M·ªôt v·ª• n·ªï b·∫•t ng·ªù l√†m r∆°i m·∫•t <b>${itemMeta(lost.id).name}</b>!`);
          if(p.equipped.weaponUid===lost.uid) p.equipped.weaponUid=null;
          if(p.equipped.armorUid===lost.uid) p.equipped.armorUid=null;
        } else {
          addLog("üö® Super Sentai World: h·ªón lo·∫°n lan r·ªông (-6 th·ªÉ l·ª±c).");
        }
      }
    },

    { key:"Black Clover World", match:(name)=>/black\s*clover|clover/i.test(name), onEnter:(p)=>{
        p.stamina = Math.max(0, p.stamina - 6);
        if(Math.random() < 0.35){
          const mpLoss = Math.max(1, Math.floor(p.max.MP * 0.20));
          const hpLoss = Math.max(1, Math.floor(p.max.HP * 0.10));
          p.stats.MP = clamp(p.stats.MP - mpLoss, 0, p.max.MP);
          p.stats.HP = clamp(p.stats.HP - hpLoss, 0, p.max.HP);
          addLog("‚ô£Ô∏è Black Clover World: Mana Zone r√∫t <b>-20% MP</b> & <b>-10% HP</b> hi·ªán t·∫°i.");
        } else {
          addLog("‚ô£Ô∏è Black Clover World: kh√≠ ma l·ª±c xo√°y m·∫°nh (-6 th·ªÉ l·ª±c).");
        }
      }
    },
  ];


  function getLocationEffect(name){
    const s = name || "";
    return LOCATION_EFFECTS.find(e=>e.match(s)) || null;
  }

  function applyLocationEnter(){
    const eff = getLocationEffect(game.player.location);
    game.player.locationEffectKey = eff ? eff.key : null;
    if(eff?.onEnter) eff.onEnter(game.player);
  }



  const NPC_TRAITS = [
    "hi·ªÅn l√†nh", "tham lam", "c·ªôc c·∫±n", "h√†o s·∫£ng", "ƒëa nghi", "l√£ng m·∫°n",
    "th·ª±c d·ª•ng", "t√≤ m√≤", "l·∫°nh l√πng", "th√≠ch gi√∫p ng∆∞·ªùi", "hay c√°u", "b√≠ hi·ªÉm"
  ];

  const NPC_ROLES = [
    "th∆∞∆°ng nh√¢n", "l√≠nh g√°c", "th·∫ßy thu·ªëc", "th·ª£ r√®n", "h·ªçc gi·∫£", "k·∫ª ƒë∆∞a tin",
    "ƒë·∫°o sƒ©", "nh√† th√°m hi·ªÉm", "k·∫ª lang thang", "ch·ªß qu√°n", "ngh·ªá sƒ©", "tay m√¥i gi·ªõi"
  ];

  const RACES = [
    { id:"human", name:"Nh√¢n lo·∫°i", bonus:{CHA:+3, LUK:+1}, perk:"ƒêa d·ª•ng: +3 CHA, +1 LUK.", maxAge:90 },
    { id:"elf", name:"Tinh linh", bonus:{DEX:+4, INT:+2}, perk:"Nhanh & th√¥ng minh: +4 DEX, +2 INT.", maxAge:750 },
    { id:"dwarf", name:"Ng∆∞·ªùi l√πn", bonus:{DEF:+5, STR:+2, HP:+10}, perk:"C·ª©ng c√°p: +5 DEF, +2 STR, +10 HP.", maxAge:350 },
    { id:"orc", name:"Orc", bonus:{STR:+6, HP:+12}, perk:"S·ª©c m·∫°nh cu·ªìng b·∫°o: +6 STR, +12 HP.", maxAge:75 },
    { id:"kitsune", name:"H·ªì ly", bonus:{CHA:+5, LUK:+4}, perk:"M√™ ho·∫∑c & may m·∫Øn: +5 CHA, +4 LUK.", maxAge:1000 },
    { id:"undead", name:"B·∫•t t·ª≠", bonus:{DEF:+4, INT:+4, HP:+8}, perk:"L·∫°nh l·∫Ωo: +4 DEF, +4 INT, +8 HP.", maxAge:9999 },
    { id:"goblin", name:"Goblin (Tensura)", bonus:{DEX:+2, CHA:+1, HP:+4}, perk:"C·ªông ƒë·ªìng: +2 DEX, +1 CHA, +4 HP.", maxAge:60, tensura:true },
    { id:"hobgoblin", name:"Hobgoblin", bonus:{STR:+2, DEX:+3, HP:+8, DEF:+1}, perk:"Ti·∫øn h√≥a t·ª´ Goblin: m·∫°nh & nhanh h∆°n.", maxAge:80, evoOnly:true, tensura:true, evoFrom:"goblin" },
    { id:"goblin_king", name:"Goblin King", bonus:{STR:+4, CHA:+4, HP:+14, DEF:+2, LUK:+1}, perk:"Th·ªß lƒ©nh: aura ch·ªâ huy, tƒÉng CHA m·∫°nh.", maxAge:120, evoOnly:true, tensura:true, evoFrom:"hobgoblin" },

    { id:"ogre", name:"Ogre (Tensura)", bonus:{STR:+4, DEF:+1, HP:+10}, perk:"Chi·∫øn binh: +4 STR, +1 DEF, +10 HP.", maxAge:90, tensura:true },
    { id:"kijin", name:"Kijin", bonus:{STR:+6, DEX:+3, DEF:+2, HP:+16}, perk:"Ti·∫øn h√≥a t·ª´ Ogre: s·ª©c m·∫°nh v∆∞·ª£t b·∫≠c.", maxAge:180, evoOnly:true, tensura:true, evoFrom:"ogre" },

    { id:"direwolf", name:"Direwolf (Tensura)", bonus:{DEX:+5, STR:+2, HP:+6}, perk:"D√£ th√∫: nhanh, s√°t th∆∞∆°ng t·ªët.", maxAge:45, tensura:true },
    { id:"tempest_wolf", name:"Tempest Wolf", bonus:{DEX:+7, STR:+3, DEF:+1, HP:+12}, perk:"Ti·∫øn h√≥a t·ª´ Direwolf: b·ªÅn b·ªâ & nhanh.", maxAge:65, evoOnly:true, tensura:true, evoFrom:"direwolf" },

    { id:"lizardman", name:"Lizardman (Tensura)", bonus:{DEF:+3, STR:+2, HP:+8}, perk:"V·∫£y c·ª©ng: +3 DEF, +2 STR, +8 HP.", maxAge:70, tensura:true },
    { id:"dragonewt", name:"Dragonewt", bonus:{DEF:+5, STR:+4, DEX:+2, HP:+14}, perk:"Ti·∫øn h√≥a t·ª´ Lizardman: n·ª≠a r·ªìng.", maxAge:140, evoOnly:true, tensura:true, evoFrom:"lizardman" },

    { id:"slime", name:"Slime", bonus:{HP:+8, INT:+1}, perk:"C∆° th·ªÉ nh·∫ßy: +8 HP, +1 INT. C√≥ th·ªÉ <b>H·∫•p Th·ª•</b> ƒë·ªÉ tƒÉng tr∆∞·ªüng.", maxAge:9999, evoOnly:true, tensura:true },
    { id:"demon_slime", name:"Demon Slime", bonus:{HP:+14, INT:+3, DEF:+2}, perk:"Ti·∫øn h√≥a t·ª´ Slime: tƒÉng m·∫°nh sinh t·ªìn & ma l·ª±c.", maxAge:9999, evoOnly:true, tensura:true, evoFrom:"slime" },
    { id:"true_demon_lord", name:"Ma V∆∞∆°ng Ch√¢n Ch√≠nh", bonus:{HP:+28, STR:+6, INT:+6, DEF:+6, LUK:+2}, perk:"Th·ª©c t·ªânh: s·ª©c m·∫°nh v∆∞·ª£t chu·∫©n, kh√°ng debuff t·ªët h∆°n.", maxAge:9999, evoOnly:true, tensura:true, evoFrom:"demon_slime" },
  ];
  const raceById = (id)=> RACES.find(r=>r.id===id) || RACES[0];

  // Weighted race roll: H·ªì Ly & B·∫•t T·ª≠ c·ª±c hi·∫øm (0,0005% m·ªói t·ªôc)
  function rollRaceWeighted(){
    const r = randInt(1, 1000000);
    if(r <= 5) return raceById("kitsune");
    if(r <= 10) return raceById("undead");
    return pick(RACES.filter(x=>!x.evoOnly && x.id!=="kitsune" && x.id!=="undead"));
  }


  /** ===================== Tensura-like Progression ===================== **/
  function ensureTensuraState(){
    const p = game.player;
    p.souls ??= 0;           // ‚Äúlinh h·ªìn‚Äù t√≠ch l≈©y (gi·ªëng concept awaken)
    p.namedTitle ??= null;   // danh x∆∞ng / t√™n ƒë∆∞·ª£c ban
    p.predatorStacks ??= 0;  // s·ªë l·∫ßn h·∫•p th·ª•
  }


  function openEvolve(){
    ensureTensuraState();
    ensureEmpire();
    const p = game.player;
    const opts = EVOLUTIONS.filter(ev=>ev.from===p.raceId && ev.can(p));
    if(!opts.length){
      pushStory("Kh√¥ng c√≥ ti·∫øn ho√° kh·∫£ d·ª•ng l√∫c n√†y.");
      addLog("Ti·∫øn h√≥a: ch∆∞a ƒë·ªß ƒëi·ªÅu ki·ªán.");
      renderAll();
      return;
    }
    $menuTitle.textContent = "Ti·∫øn ho√°";
    $menuBody.innerHTML = opts.map((ev, idx)=>`
      <button class="btn btnPrimary" data-ev="${idx}">${ev.title}<br><span style="color:rgba(255,255,255,.65);font-size:12px;">${ev.desc}</span></button>
    `).join("");
    $menuBody.querySelectorAll("button[data-ev]").forEach(btn=>{
      btn.addEventListener("click", ()=>{
        const ev = opts[Number(btn.getAttribute("data-ev"))];
        if(ev.cost?.souls){ p.souls = Math.max(0, (p.souls||0) - ev.cost.souls); }
        p.raceId = ev.to;
        ev.onEvolve?.(p);
        computeStats(false);
        pushStory(`üåÄ ${ev.title} th√†nh c√¥ng!`);
        addLog(`Ti·∫øn h√≥a: ${ev.from} ‚Üí ${ev.to}`);
        $overlayMenu.style.display="none";
        renderAll();
      });
    });
    showOverlay("overlayMenu");
  }
  const EVOLUTIONS = [
    {
      from:"slime", to:"demon_slime",
      title:"Ti·∫øn h√≥a: Demon Slime",
      desc:"Y√™u c·∫ßu: Lv ‚â• 30 + c√≥ <b>Predator</b>.",
      can:(p)=> p.level>=30 && hasSkill("ts_predator"),
      onEvolve:(p)=>{ addLog("üåÄ B·∫°n ti·∫øn h√≥a th√†nh <b>Demon Slime</b>!"); }
    },
    {
      from:"demon_slime", to:"true_demon_lord",
      title:"Th·ª©c t·ªânh: Ma V∆∞∆°ng Ch√¢n Ch√≠nh",
      desc:"Y√™u c·∫ßu: Lv ‚â• 60 + <b>100 Souls</b> + c√≥ passive <b>Demon Lord Seed</b>.",
      can:(p)=> p.level>=60 && (p.souls||0)>=100 && p.passives.includes("tp_demon_lord_seed"),
      onEvolve:(p)=>{
        if(!p.passives.includes("tp_true_demon_lord")) p.passives.push("tp_true_demon_lord");
        addLog("üî• B·∫°n <b>TH·ª®C T·ªàNH</b>! Tr·ªü th√†nh <b>Ma V∆∞∆°ng Ch√¢n Ch√≠nh</b>.");
      }
    },

    {
      from:"goblin", to:"hobgoblin",
      title:"Ti·∫øn h√≥a: Hobgoblin",
      desc:"Y√™u c·∫ßu: Lv ‚â• 15 + <b>10 Souls</b>.",
      can:(p)=> p.level>=15 && (p.souls||0)>=10,
      cost:{souls:10},
      onEvolve:(p)=>{ addLog("üåÄ B·∫°n ti·∫øn h√≥a th√†nh <b>Hobgoblin</b>!"); }
    },
    {
      from:"hobgoblin", to:"goblin_king",
      title:"Ti·∫øn h√≥a: Goblin King",
      desc:"Y√™u c·∫ßu: Lv ‚â• 35 + <b>35 Souls</b> + ƒê·∫ø ch·∫ø Lv ‚â• 2.",
      can:(p)=> p.level>=35 && (p.souls||0)>=35 && (game.world.empire?.level||1)>=2,
      cost:{souls:35},
      onEvolve:(p)=>{ addLog("üëë B·∫°n tr·ªü th√†nh <b>Goblin King</b>!"); }
    },
    {
      from:"ogre", to:"kijin",
      title:"Ti·∫øn h√≥a: Kijin",
      desc:"Y√™u c·∫ßu: Lv ‚â• 25 + <b>20 Souls</b>.",
      can:(p)=> p.level>=25 && (p.souls||0)>=20,
      cost:{souls:20},
      onEvolve:(p)=>{ addLog("üåÄ B·∫°n ti·∫øn h√≥a th√†nh <b>Kijin</b>!"); }
    },
    {
      from:"direwolf", to:"tempest_wolf",
      title:"Ti·∫øn h√≥a: Tempest Wolf",
      desc:"Y√™u c·∫ßu: Lv ‚â• 18 + <b>12 Souls</b>.",
      can:(p)=> p.level>=18 && (p.souls||0)>=12,
      cost:{souls:12},
      onEvolve:(p)=>{ addLog("üê∫ B·∫°n ti·∫øn h√≥a th√†nh <b>Tempest Wolf</b>!"); }
    },
    {
      from:"lizardman", to:"dragonewt",
      title:"Ti·∫øn h√≥a: Dragonewt",
      desc:"Y√™u c·∫ßu: Lv ‚â• 22 + <b>16 Souls</b>.",
      can:(p)=> p.level>=22 && (p.souls||0)>=16,
      cost:{souls:16},
      onEvolve:(p)=>{ addLog("üêâ B·∫°n ti·∫øn h√≥a th√†nh <b>Dragonewt</b>!"); }
    },
  ];

  function availableEvolutions(){
    const p = game.player;
    return EVOLUTIONS.filter(e=>e.from===p.raceId && e.can(p));
  }

  function doEvolve(toId){
    const p = game.player;
    const evo = EVOLUTIONS.find(e=>e.from===p.raceId && e.to===toId);
    if(!evo || !evo.can(p)) return false;
    p.raceId = toId;
    const r = raceById(toId);
    p.maxAge = r.maxAge || p.maxAge;
    computeStats(true);
    evo.onEvolve?.(p);
    pushStory(`B·∫°n c·∫£m nh·∫≠n d√≤ng ma l·ª±c thay ƒë·ªïi‚Ä¶ <b>${evo.title}</b>.`);
    saveAuto();
    renderAll();
    return true;
  }

  function canNameSelf(){
    const p = game.player;
    return !p.namedTitle && (hasSkill("ts_great_sage") || p.passives.includes("tp_voice_world"));
  }
  function doNameSelf(title){
    const p = game.player;
    if(!canNameSelf()) return false;
    const t = (title||"").trim().slice(0,20);
    if(!t) return false;
    p.namedTitle = t;
    if(!p.passives.includes("tp_naming")) p.passives.push("tp_naming");
    addLog(`üè∑Ô∏è B·∫°n nh·∫≠n danh x∆∞ng: <b>${t}</b>.`);
    pushStory(`M·ªôt gi·ªçng n√≥i vang l√™n: <b>"${t}"</b>. S·ª©c m·∫°nh nh∆∞ ƒë∆∞·ª£c ƒë·ªãnh danh.`);
    computeStats(true);
    saveAuto();
    renderAll();
    return true;
  }


  const ELEMENTS = ["L·ª≠a","BƒÉng","S·∫•m","Gi√≥","ƒê·∫•t","B√≥ng","√Ånh","N∆∞·ªõc","ƒê·ªôc","Tinh T√∫"];
  const FORMS = ["Ch√©m","ƒê√¢m","B·ªôc Ph√°","M≈©i T√™n","Tia","V√≤ng Tr√≤n","B√£o","K·∫øt Gi·ªõi","H√∫t","·∫§n Ch√∫"];
  const MODS = ["Nhanh","N·∫∑ng","Xuy√™n Gi√°p","H·ªìi Ph·ª•c","T√™ Li·ªát","ƒê·ªôc T·ªë","TƒÉng L·ª±c","Suy Y·∫øu","B·∫°o K√≠ch","Th·∫ßn T·ªëc"];
  const RARITY = ["trash","common","rare","legend","legendary"];
  function rarityRank(r){ return ({trash:0, common:1, rare:2, legend:3, legendary:4}[r]||0); }
  const rarityLabel = (r)=>({trash:"Trash", common:"Common", rare:"Rare", legend:"Legend", legendary:"Legendary"}[r]||r);

  function makeActiveSkill(i){
    const el = ELEMENTS[i % ELEMENTS.length];
    const form = FORMS[(i*3) % FORMS.length];
    const mod = MODS[(i*7) % MODS.length];

    let rarity = "common";
    if(i >= 75 && i < 92) rarity = "rare";
    if(i >= 92 && i < 98) rarity = "legend";
    if(i >= 98) rarity = "legendary";

    const baseMp = rarity==="common" ? randInt(2,4) : rarity==="rare" ? randInt(4,6) : rarity==="legend" ? randInt(6,8) : randInt(8,10);
    const cd = rarity==="common" ? randInt(0,1) : rarity==="rare" ? randInt(1,2) : rarity==="legend" ? randInt(2,3) : randInt(3,4);
    const mult = rarity==="common" ? (1.05 + (i%7)*0.03) : rarity==="rare" ? (1.35 + (i%7)*0.04) : rarity==="legend" ? (1.75 + (i%6)*0.05) : (2.25 + (i%5)*0.06);

    const types = ["dmg","dmg","dmg","heal","shield","drain","poison","stun","debuff","buff"];
    const type = types[i % types.length];
    const scale = (i % 3 === 0) ? "STR" : (i % 3 === 1) ? "INT" : "DEX";

    let extra = {};
    let desc = "";
    if(type==="heal"){
      extra.healPct = rarity==="common" ? 0.18 : rarity==="rare" ? 0.26 : rarity==="legend" ? 0.34 : 0.45;
      desc = `H·ªìi ${Math.round(extra.healPct*100)}% HP (d·ª±a tr√™n Max HP).`;
    } else if(type==="shield"){
      extra.shieldPct = rarity==="common" ? 0.18 : rarity==="rare" ? 0.26 : rarity==="legend" ? 0.34 : 0.45;
      desc = `Nh·∫≠n l√° ch·∫Øn ${Math.round(extra.shieldPct*100)}% Max HP (2 l∆∞·ª£t).`;
    } else if(type==="drain"){
      extra.lifesteal = rarity==="common" ? 0.18 : rarity==="rare" ? 0.24 : rarity==="legend" ? 0.30 : 0.38;
      desc = `G√¢y s√°t th∆∞∆°ng v√† h√∫t m√°u (${Math.round(extra.lifesteal*100)}% dmg).`;
    } else if(type==="poison"){
      extra.dotPct = rarity==="common" ? 0.07 : rarity==="rare" ? 0.10 : rarity==="legend" ? 0.13 : 0.16;
      extra.dotTurns = rarity==="common" ? 2 : rarity==="rare" ? 3 : 4;
      desc = `G√¢y ƒë·ªôc: m·∫•t ${Math.round(extra.dotPct*100)}% Max HP m·ªói l∆∞·ª£t trong ${extra.dotTurns} l∆∞·ª£t.`;
    } else if(type==="stun"){
      extra.stunChance = rarity==="common" ? 0.20 : rarity==="rare" ? 0.28 : rarity==="legend" ? 0.36 : 0.45;
      desc = `C√≥ ${Math.round(extra.stunChance*100)}% l√†m cho√°ng (qu√°i m·∫•t l∆∞·ª£t k·∫ø).`;
    } else if(type==="debuff"){
      extra.defDown = rarity==="common" ? 0.12 : rarity==="rare" ? 0.18 : rarity==="legend" ? 0.24 : 0.32;
      extra.debuffTurns = rarity==="common" ? 2 : rarity==="rare" ? 3 : 4;
      desc = `Gi·∫£m DEF qu√°i ${Math.round(extra.defDown*100)}% trong ${extra.debuffTurns} l∆∞·ª£t.`;
    } else if(type==="buff"){
      extra.buffStat = (i % 2 === 0) ? "STR" : (i % 3 === 0) ? "DEX" : "INT";
      extra.buffPct = rarity==="common" ? 0.14 : rarity==="rare" ? 0.20 : rarity==="legend" ? 0.27 : 0.36;
      extra.buffTurns = rarity==="common" ? 2 : rarity==="rare" ? 3 : 4;
      desc = `TƒÉng ${extra.buffStat} ${Math.round(extra.buffPct*100)}% trong ${extra.buffTurns} l∆∞·ª£t.`;
    } else {
      extra.pierce = (mod==="Xuy√™n Gi√°p") ? (rarity==="common" ? 0.20 : rarity==="rare" ? 0.30 : rarity==="legend" ? 0.40 : 0.55) : 0.0;
      extra.crit = (mod==="B·∫°o K√≠ch") ? (rarity==="common" ? 0.12 : rarity==="rare" ? 0.18 : rarity==="legend" ? 0.25 : 0.33) : 0.0;
      desc = `G√¢y s√°t th∆∞∆°ng (${scale})${extra.pierce?`, xuy√™n DEF`:""}${extra.crit?`, c√≥ ch√≠ m·∫°ng`:""}.`;
    }

    const name = `${el} ${form} ${mod}`;
    return {
      id: `sk_${i+1}`,
      name,
      kind: "active",
      rarity,
      mp: baseMp,
      cd,
      mult,
      scale,
      type,
      desc,
      extra,
    };
  }

  const ULTIMATES = [
    { id:"ult_void_break", name:"Void Break", mp:8, cd:999, rarity:"legendary", type:"dmg", scale:"STR", mult:3.0, desc:"Dmg c·ª±c l·ªõn, xuy√™n DEF m·∫°nh.", extra:{pierce:0.65, crit:0.18} },
    { id:"ult_phoenix", name:"Phoenix Rebirth", mp:9, cd:999, rarity:"legendary", type:"heal", scale:"INT", mult:0, desc:"H·ªìi ƒë·∫ßy HP + l√° ch·∫Øn.", extra:{healFull:true, shieldPct:0.35, shieldTurns:2} },
    { id:"ult_time_stop", name:"Time Stop", mp:9, cd:999, rarity:"legendary", type:"buff", scale:"INT", mult:0, desc:"B·∫°n ƒë∆∞·ª£c th√™m 1 l∆∞·ª£t + tƒÉng DEX.", extra:{extraTurn:true, buffStat:"DEX", buffPct:0.30, buffTurns:2} },
    { id:"ult_judgement", name:"Judgement", mp:8, cd:999, rarity:"legendary", type:"dmg", scale:"INT", mult:2.6, desc:"Dmg chu·∫©n + h·ªìi MP theo s√°t th∆∞∆°ng.", extra:{pure:true, mpRefund:0.22} },
    { id:"ult_meteor", name:"Meteor Fall", mp:10, cd:999, rarity:"legendary", type:"dmg", scale:"INT", mult:3.4, desc:"Dmg c·ª±c l·ªõn.", extra:{crit:0.10} },
    { id:"ult_dragon_rage", name:"Dragon Rage", mp:9, cd:999, rarity:"legendary", type:"buff", scale:"STR", mult:0, desc:"TƒÉng STR + DEF, mi·ªÖn 1 ƒë√≤n.", extra:{buffStat:"STR", buffPct:0.35, buffTurns:3, guard:true} },
    { id:"ult_abyss_chain", name:"Abyss Chain", mp:8, cd:999, rarity:"legendary", type:"debuff", scale:"CHA", mult:1.8, desc:"G√¢y dmg + gi·∫£m DEF m·∫°nh.", extra:{defDown:0.40, debuffTurns:4, pierce:0.25} },
    { id:"ult_stellar_lance", name:"Stellar Lance", mp:9, cd:999, rarity:"legendary", type:"dmg", scale:"DEX", mult:2.9, desc:"Dmg nhanh + t·ªâ l·ªá cho√°ng.", extra:{stunChance:0.40, pierce:0.30} },
    { id:"ult_sanctuary", name:"Sanctuary", mp:8, cd:999, rarity:"legendary", type:"shield", scale:"INT", mult:0, desc:"K·∫øt gi·ªõi kh·ªïng l·ªì.", extra:{shieldPct:0.55, shieldTurns:3, cleanse:true} },
    { id:"ult_blood_oath", name:"Blood Oath", mp:7, cd:999, rarity:"legendary", type:"drain", scale:"STR", mult:2.4, desc:"H√∫t m√°u c·ª±c m·∫°nh.", extra:{lifesteal:0.55, crit:0.20} },
    { id:"ult_world_cleave", name:"World Cleave", mp:10, cd:999, rarity:"legendary", type:"dmg", scale:"STR", mult:3.2, desc:"Ch√©m n·ª©t ƒë·∫•t.", extra:{pierce:0.45} },
    { id:"ult_mind_overflow", name:"Mind Overflow", mp:9, cd:999, rarity:"legendary", type:"buff", scale:"INT", mult:0, desc:"Full MP + tƒÉng INT.", extra:{mpFull:true, buffStat:"INT", buffPct:0.40, buffTurns:3} },
  ];

  const BASIC_ATTACK = { id:"basic_attack", name:"ƒê√°nh Th∆∞·ªùng", mp:0, cd:0, rarity:"common", type:"dmg", scale:"STR", mult:1.0, desc:"ƒê√≤n ƒë√°nh th∆∞·ªùng: kh√¥ng t·ªën MP, kh√¥ng cooldown.", extra:{} };

  const ACTIVE_SKILLS = [BASIC_ATTACK].concat(Array.from({length:100}, (_,i)=>makeActiveSkill(i)).concat(ULTIMATES.map(u=>({ ...u, kind:"ultimate", cd:999 }))));

  // =========================
  // Tensura (Slime) Pack ‚Äî skills (inspired)
  // L∆∞u √Ω: tr√°nh spoil plot; ch·ªâ th√™m h·ªá th·ªëng/k·ªπ nƒÉng l·∫•y c·∫£m h·ª©ng.
  // =========================
  const SLIME_PACK_SKILLS = [
    { id:"ts_predator", name:"Predator (K·∫ª Nu·ªët)", kind:"active", rarity:"legendary", mp:6, cd:3, type:"drain", scale:"STR", mult:2.2,
      desc:"Nu·ªët ch·ª≠ng m·ª•c ti√™u: g√¢y dmg l·ªõn + h√∫t m√°u m·∫°nh.", extra:{lifesteal:0.55, pierce:0.25, crit:0.10} },
    { id:"ts_great_sage", name:"Great Sage (ƒê·∫°i Hi·ªÅn Tri)", kind:"active", rarity:"legendary", mp:5, cd:4, type:"buff", scale:"INT", mult:0,
      desc:"Ph√¢n t√≠ch & t·ªëi ∆∞u: h·ªìi MP + tƒÉng INT + th√™m 1 l∆∞·ª£t.", extra:{mpFull:true, buffStat:"INT", buffPct:0.30, buffTurns:2, extraTurn:true} },
    { id:"ts_demon_lord_haki", name:"Demon Lord Haki (Ma V∆∞∆°ng B√° Kh√≠)", kind:"active", rarity:"legend", mp:4, cd:4, type:"debuff", scale:"CHA", mult:1.9,
      desc:"√Åp ch·∫ø tinh th·∫ßn: g√¢y dmg + gi·∫£m DEF m·∫°nh.", extra:{defDown:0.35, debuffTurns:3, pierce:0.20} },
    { id:"ts_black_lightning", name:"Black Lightning (H·∫Øc L√¥i)", kind:"active", rarity:"legend", mp:4, cd:2, type:"stun", scale:"INT", mult:1.8,
      desc:"S√©t ƒëen: dmg + c√≥ t·ªâ l·ªá cho√°ng cao.", extra:{stunChance:0.42, pierce:0.15} },
    { id:"ts_shadow_mist", name:"Shadow Mist (·∫¢nh S∆∞∆°ng)", kind:"active", rarity:"rare", mp:3, cd:2, type:"poison", scale:"INT", mult:1.2,
      desc:"S∆∞∆°ng ƒë·ªôc: g·∫Øn ƒë·ªôc theo % Max HP.", extra:{dotPct:0.12, dotTurns:3} },
    { id:"ts_uriel", name:"Uriel (Lord of Vows)", kind:"ultimate", rarity:"legendary", mp:10, cd:999, type:"shield", scale:"INT", mult:0,
      desc:"K·∫øt gi·ªõi b·∫£o h·ªô: Shield c·ª±c l·ªõn + g·ªôt r·ª≠a.", extra:{shieldPct:0.70, shieldTurns:3, cleanse:true} },
    { id:"ts_beelzebuth", name:"Beelzebuth (Lord of Gluttony)", kind:"ultimate", rarity:"legendary", mp:10, cd:999, type:"drain", scale:"STR", mult:3.1,
      desc:"Nu·ªët s·∫°ch: dmg c·ª±c l·ªõn + h√∫t m√°u.", extra:{lifesteal:0.65, pierce:0.45, crit:0.12} },
    { id:"ts_megido", name:"Megiddo (Thi√™n Quang)", kind:"ultimate", rarity:"legendary", mp:9, cd:999, type:"dmg", scale:"INT", mult:3.0,
      desc:"M∆∞a tia s√°ng: s√°t th∆∞∆°ng thu·∫ßn, xuy√™n DEF m·∫°nh.", extra:{pure:true, pierce:0.55, crit:0.08} },
    { id:"ts_storm_blast", name:"Storm Blast (B·∫°o Phong)", kind:"ultimate", rarity:"legendary", mp:9, cd:999, type:"dmg", scale:"DEX", mult:2.9,
      desc:"B√£o ch√©m: dmg nhanh + xuy√™n gi√°p.", extra:{pierce:0.40, crit:0.12} },
  ];

  // Inject Tensura skills into skill list (id kh√¥ng tr√πng)
  for(const s of SLIME_PACK_SKILLS){
    if(!ACTIVE_SKILLS.some(x=>x.id===s.id)) ACTIVE_SKILLS.push(s);
  }

  function makePassive(i){
    let rarity = "common";
    if(i >= 75 && i < 92) rarity = "rare";
    if(i >= 92 && i < 98) rarity = "legend";
    if(i >= 98) rarity = "legendary";

    const types = ["hpRegen","mpRegen","crit","pierce","gold","exp","dmg","def","maxHP","maxMP"];
    const type = types[i % types.length];

    const base = rarity==="common" ? 0.06 : rarity==="rare" ? 0.09 : rarity==="legend" ? 0.12 : 0.16;
    const val = +(base + (i%7)*0.01).toFixed(2);

    const name = `B·ªã ƒê·ªông #${String(i+1).padStart(3,"0")} ‚Äî ${type}`;
    const descMap = {
      hpRegen:`M·ªói l∆∞·ª£t h·ªìi ${Math.round(val*100)}% Max HP.`,
      mpRegen:`M·ªói l∆∞·ª£t h·ªìi ${Math.round(val*100)}% Max MP.`,
      crit:`+${Math.round(val*100)}% t·ªâ l·ªá ch√≠ m·∫°ng.`,
      pierce:`+${Math.round(val*100)}% xuy√™n gi√°p.`,
      gold:`+${Math.round(val*100)}% v√†ng khi ki·∫øm ti·ªÅn.`,
      exp:`+${Math.round(val*100)}% EXP nh·∫≠n ƒë∆∞·ª£c.`,
      dmg:`+${Math.round(val*100)}% s√°t th∆∞∆°ng g√¢y ra.`,
      def:`+${Math.round(val*100)}% DEF t·ªïng.`,
      maxHP:`+${Math.round(val*100)}% Max HP.`,
      maxMP:`+${Math.round(val*100)}% Max MP.`,
    };
    return { id:`ps_${i+1}`, name, rarity, type, val, desc: descMap[type] || "TƒÉng ch·ªâ s·ªë." };
  }
  const PASSIVES = Array.from({length:100}, (_,i)=>makePassive(i));

  // =========================
  // Tensura (Slime) Pack ‚Äî passives (inspired)
  // =========================
  const SLIME_PACK_PASSIVES = [
    { id:"tp_voice_world", name:"Voice of the World", rarity:"legendary", type:"mpRegen", val:0.16, desc:"M·ªói l∆∞·ª£t h·ªìi 16% Max MP." },
    { id:"tp_magic_sense", name:"Magic Sense", rarity:"legend", type:"crit", val:0.14, desc:"+14% t·ªâ l·ªá ch√≠ m·∫°ng (nh·∫≠n bi·∫øt ƒëi·ªÉm y·∫øu)." },
    { id:"tp_storm_crest", name:"Storm's Crest", rarity:"legendary", type:"pierce", val:0.18, desc:"+18% xuy√™n gi√°p (b·∫£o h·ªô b√£o t·ªë)." },
    { id:"tp_naming", name:"Naming", rarity:"legend", type:"dmg", val:0.12, desc:"+12% s√°t th∆∞∆°ng (s·ª©c m·∫°nh t·ª´ danh x∆∞ng)." },
    { id:"tp_regeneration", name:"Ultra Regeneration", rarity:"legendary", type:"hpRegen", val:0.18, desc:"M·ªói l∆∞·ª£t h·ªìi 18% Max HP." },
    { id:"tp_shapeshift", name:"Universal Shapeshift", rarity:"legend", type:"maxHP", val:0.12, desc:"+12% Max HP." },
    { id:"tp_thought_accel", name:"Thought Acceleration", rarity:"legend", type:"maxMP", val:0.14, desc:"+14% Max MP." },
    { id:"tp_demon_lord_seed", name:"Demon Lord Seed", rarity:"legendary", type:"def", val:0.16, desc:"+16% DEF t·ªïng." },
    { id:"tp_raphael", name:"Raphael-like Core", rarity:"legendary", type:"mpRegen", val:0.22, desc:"M·ªói l∆∞·ª£t h·ªìi 22% Max MP (h·ªó tr·ª£ ph√¢n t√≠ch n√¢ng cao)." },
    { id:"tp_true_demon_lord", name:"True Demon Lord", rarity:"legendary", type:"dmg", val:0.20, desc:"+20% s√°t th∆∞∆°ng g√¢y ra (th·ª©c t·ªânh)." },
  ];

  for(const psv of SLIME_PACK_PASSIVES){
    if(!PASSIVES.some(x=>x.id===psv.id)) PASSIVES.push(psv);
  }

  // =========================
  // PROFESSION SYSTEM (Ch·ª©c nghi·ªáp)
  // =========================
  const PROF_RARITY_POOL = ["common","common","common","common","common","common","common","common","common","common","common","common","common","common","common","common","common","common","common","common","rare","rare","rare","rare","legend","legendary","mythic"];;
  const PROFESSIONS = Array.from({length:60}, (_,i)=>makeProfession(i));

  // Ensure c√≥ √≠t nh·∫•t 1 ngh·ªÅ mythic ƒë·ªÉ roll ra ƒë∆∞·ª£c (d√π t·ªâ l·ªá c·ª±c th·∫•p)
  if(!PROFESSIONS.some(p=>p.rarity==="mythic")){ PROFESSIONS[0] = makeProfession(0, "mythic"); }

  // Mythic profession rate: 0,01% (1/10.000)
  function rollProfessionRarity(){
    const r = randInt(1, 1000000);
    if(r <= 100) return "mythic";
    // Ph·∫ßn c√≤n l·∫°i chia theo t·ªâ l·ªá pool c≈© (kh√¥ng t√≠nh mythic)
    if(r <= 100 + 38458) return "legendary";
    if(r <= 100 + 38458 + 38458) return "legend";
    if(r <= 100 + 38458 + 38458 + 153831) return "rare";
    return "common";
  }

  
function makeProfession(i, forcedRarity=null){
  // IMPORTANT: Deterministic professions (stable across reload) so save kh√¥ng b·ªã "random ch·ª©c nghi·ªáp"
  const themes = [
    ["L√≠nh ƒë√°nh thu√™","STR","DEX"], ["H·ªçc gi·∫£","INT","MP"], ["Nh·∫°c sƒ©","CHA","MP"], ["ƒê·∫°o t·∫∑c","DEX","LUK"],
    ["Hi·ªáp sƒ©","DEF","HP"], ["Ph√°p s∆∞","INT","MP"], ["Th·ª£ sƒÉn","DEX","STR"], ["Tu sƒ©","MP","HP"],
    ["Th·ª£ r√®n","STR","DEF"], ["Nh√† th√°m hi·ªÉm","DEX","HP"], ["Nh√† gi·∫£ kim","INT","LUK"], ["Th∆∞∆°ng nh√¢n","CHA","LUK"],
    ["Ki·∫øm sƒ©","STR","DEX"], ["Cung th·ªß","DEX","LUK"], ["V√µ tƒÉng","STR","HP"], ["Chi·∫øn l∆∞·ª£c gia","INT","CHA"],
    ["Truy·ªÅn gi√°o","CHA","HP"], ["Ph√π th·ªßy","INT","LUK"], ["ƒê·∫•u sƒ©","STR","HP"], ["K·ªµ binh","DEX","DEF"]
  ];
  const t = themes[i % themes.length];

  // rarity theo ch·ªâ s·ªë i ƒë·ªÉ lu√¥n ·ªïn ƒë·ªãnh
  let rarity = forcedRarity;
  if(!rarity){
    if(i===0) rarity = "mythic";
    else if(i<=2) rarity = "legendary";
    else if(i<=7) rarity = "legend";
    else if(i<=18) rarity = "rare";
    else rarity = "common";
  }

  const name = `${t[0]} #${i+1}`;
  const base = (rarity==="common")?1:(rarity==="rare")?7:(rarity==="legend")?12:(rarity==="legendary")?18:26;
  const bonus = {HP:0, MP:0, STR:0, DEX:0, INT:0, CHA:0, LUK:0, DEF:0};

  const addKey = (k, v)=>{ if(k==="HP"||k==="MP") bonus[k]+=v*2; else bonus[k]+=v; };
  addKey(t[1], base);
  addKey(t[2], base);
  if(rarity==="rare"){ bonus.HP += 4; bonus.DEF += 2; }
  if(rarity==="legend"){ bonus.HP += 10; bonus.DEF += 4; bonus.LUK += 1; }
  if(rarity==="legendary" || rarity==="mythic"){
    bonus.HP += base*2;
    bonus.DEF += Math.max(1, Math.floor(base/2));
    bonus.LUK += 1;
  }
  const perk = `Bonus: ${fmtBonus(bonus)}.`;
  return { id:`prof_${i}`, name, rarity, bonus, perk };
}
  function professionById(id){ return PROFESSIONS.find(p=>p.id===id) || PROFESSIONS[0]; }
  function rollProfession(){
    const rarity = rollProfessionRarity();
    let pool = PROFESSIONS.filter(p=>p.rarity===rarity);
    if(!pool.length){
      // fallback an to√†n
      const order = ["legendary","legend","rare","common"];
      for(const r of order){ pool = PROFESSIONS.filter(p=>p.rarity===r); if(pool.length) break; }
    }
    return pick(pool.length ? pool : PROFESSIONS);
  }

  function fmtBonus(b){
    const parts=[];
    for(const k of ["HP","MP","STR","DEX","INT","CHA","LUK","DEF"]){
      const v=b[k]||0; if(!v) continue;
      parts.push(`${k}${v>0?"+":""}${v}`);
    }
    return parts.join(", ") || "‚Äî";
  }


  function makeWeakness(i){
    const kinds = ["Frail","Slow","Cursed","Greedy","Forgetful","Glass Mind","Hollow Bones","Coward","Clumsy","Sickly"];
    const k = kinds[i % kinds.length];
    const severity = (i%5)+1;
    const name = `Nh∆∞·ª£c #${String(i+1).padStart(3,"0")} ‚Äî ${k}`;
    const effects = {
      Frail: {HP: -(4*severity), DEF: -(1*severity)},
      Slow: {DEX: -(2*severity)},
      Cursed: {LUK: -(2*severity)},
      Greedy: {goldMult: -(0.08*severity)},
      Forgetful: {mpCostMult: +(0.06*severity)},
      "Glass Mind": {INT: -(2*severity), MP: -(2*severity)},
      "Hollow Bones": {STR: -(2*severity), HP: -(3*severity)},
      Coward: {dmgTakenMult: +(0.06*severity)},
      Clumsy: {critMult: -(0.05*severity), DEX: -(1*severity)},
      Sickly: {hpRegenMult: -(0.20*severity), HP: -(2*severity)},
    };
    const eff = effects[k];
    const parts = [];
    for(const [kk,vv] of Object.entries(eff)){
      if(typeof vv === "number" && ["goldMult","mpCostMult","dmgTakenMult","critMult","hpRegenMult"].includes(kk)){
        parts.push(`${kk} ${vv>0?"+":""}${Math.round(vv*100)}%`);
      } else {
        parts.push(`${kk} ${vv>0?"+":""}${vv}`);
      }
    }
    return { id:`wk_${i+1}`, name, kind:k, severity, eff, desc: parts.join(", ") };
  }
  const WEAKNESSES = Array.from({length:100}, (_,i)=>makeWeakness(i));

  const skillById = (id)=> ACTIVE_SKILLS.find(s=>s.id===id) || null;
  const passiveById = (id)=> PASSIVES.find(p=>p.id===id) || null;

  const BLESSINGS = Array.from({length:200}, (_,i)=>{
    const themes = ["M∆∞a", "Gi√≥", "L·ª≠a", "BƒÉng", "B√≥ng", "√Ånh", "ƒê√°", "S·∫•m", "M·ªôc", "Tinh T√∫"];
    const t = themes[i % themes.length];
    const name = `Ph∆∞·ªõc ${t} #${String(i+1).padStart(3,"0")}`;
    const effects = [
      {stat:"HP", delta: 2},
      {stat:"MP", delta: 1},
      {stat:"STR", delta: 1},
      {stat:"DEX", delta: 1},
      {stat:"INT", delta: 1},
      {stat:"CHA", delta: 1},
      {stat:"LUK", delta: 1},
      {stat:"DEF", delta: 1},
    ];
    const eff = effects[i % effects.length];
    const delta = eff.delta + (i % 12 === 0 ? 1 : 0);
    return { id:`bl_${i+1}`, name, stat: eff.stat, delta, desc:`+${delta} ${eff.stat}` };
  });
  const HERO_BLESSING = {
    id:"hero_blessing",
    name:"Ph∆∞·ªõc L√†nh Anh H√πng",
    desc:"S·ª©c m·∫°nh th√°nh ho√°. +20 t·∫•t c·∫£ stat, +200 HP/MP. M·ªü gi·ªõi h·∫°n s·ª©c m·∫°nh (Lv hi·ªáu l·ª±c 999).",
    bonus:{HP:200, MP:200, STR:20, DEX:20, INT:20, CHA:20, LUK:20, DEF:20},
    special:true
  };

  function randomBlessing(){
    const owned = new Set(game.player.blessings.map(b=>b.id));
    const pool = BLESSINGS.filter(b=>!owned.has(b.id));
    return pick(pool.length ? pool : BLESSINGS);
  }

  const GODS = [
    { id:"rain", name:"Th·∫ßn M∆∞a", desc:"Thi√™n v·ªÅ HP/DEF/MP. 50 t·∫ßng." },
    { id:"flame", name:"Th·∫ßn L·ª≠a", desc:"Thi√™n v·ªÅ STR/ATK. 50 t·∫ßng." },
    { id:"storm", name:"Th·∫ßn S·∫•m", desc:"Thi√™n v·ªÅ DEX/crit. 50 t·∫ßng." },
    { id:"shade", name:"Th·∫ßn B√≥ng", desc:"Thi√™n v·ªÅ ƒë·ªôc/nh∆∞·ª£c ho√°. 50 t·∫ßng." },
    { id:"light", name:"Th·∫ßn √Ånh", desc:"Thi√™n v·ªÅ h·ªìi ph·ª•c/k·∫øt gi·ªõi. 50 t·∫ßng." },
    { id:"star", name:"Th·∫ßn Tinh T√∫", desc:"Thi√™n v·ªÅ INT/MP. 50 t·∫ßng." },
  ];
  const godById = (id)=> GODS.find(g=>g.id===id) || GODS[0];

  const ITEM_DB = {
    potion: { id:"potion", name:"Thu·ªëc H·ªìi HP", type:"consumable", rarity:"trash", price: 25, desc:"H·ªìi 15 HP.", eff:{hp:15} },
    ether:  { id:"ether",  name:"Tinh Th·ªÉ MP", type:"consumable", rarity:"trash", price: 25, desc:"H·ªìi 8 MP.", eff:{mp:8} },
    hi_potion: { id:"hi_potion", name:"ƒê·∫°i H·ªìi HP", type:"consumable", rarity:"common", price: 80, desc:"H·ªìi 40 HP.", eff:{hp:40} },
    hi_ether:  { id:"hi_ether",  name:"ƒê·∫°i H·ªìi MP", type:"consumable", rarity:"common", price: 80, desc:"H·ªìi 20 MP.", eff:{mp:20} },
    lifepotion: { id:"lifepotion", name:"Thu·ªëc TƒÉng Tu·ªïi Th·ªç", type:"consumable", rarity:"rare", price:900, desc:"TƒÉng tu·ªïi th·ªç t·ªëi ƒëa +15.", eff:{maxAge:15} },
luck_elixir: { id:"luck_elixir", name:"Luck Elixir", type:"consumable", rarity:"legendary", price:0, desc:"TƒÉng may m·∫Øn trong 2 turn: gacha x·ªãn h∆°n, r√®n d·ªÖ h∆°n.", eff:{luckTurns:2} },

    ore: { id:"ore", name:"Qu·∫∑ng R√®n", type:"material", rarity:"common", price: 35, desc:"D√πng ƒë·ªÉ n√¢ng c·∫•p v≈© kh√≠/gi√°p." },

    wooden_sword: { id:"wooden_sword", name:"Ki·∫øm G·ªó", type:"weapon", rarity:"common", price:120, atk:3, spd:0, desc:"ATK +3." },
    iron_sword:   { id:"iron_sword",   name:"Ki·∫øm S·∫Øt", type:"weapon", rarity:"common", price:240, atk:6, spd:0, desc:"ATK +6." },
    steel_sword:  { id:"steel_sword",  name:"Ki·∫øm Th√©p", type:"weapon", rarity:"rare", price:520, atk: 14, spd:1, passive:{kind:"crit", crit:0.10, dmg:0.08, note:"B·∫°o k√≠ch +10%, s√°t th∆∞∆°ng +8%"}, desc:"ATK +10, SPD +1." },
    rune_dagger:  { id:"rune_dagger",  name:"Dao Kh·∫Øc ·∫§n", type:"weapon", rarity:"rare", price:620, atk: 13, spd:2, passive:{kind:"speed", evasion:0.08, note:"N√© +8% (·∫©n)"}, desc:"ATK +9, SPD +2." },
    dragonblade:  { id:"dragonblade",  name:"Long ƒêao", type:"weapon", rarity:"legend", price:2100, atk: 30, spd:2, passive:{kind:"pierce", pierce:0.30, dmg:0.16, note:"Xuy√™n gi√°p 30%, s√°t th∆∞∆°ng +16%"}, desc:"ATK +18, SPD +2." },
    archmage_staff:{ id:"archmage_staff", name:"Tr∆∞·ª£ng ƒê·∫°i Ph√°p", type:"weapon", rarity:"legend", price:2300, atk: 28, spd:1, passive:{kind:"arcane", mpRegen:3, pure:0.12, note:"H·ªìi MP +3/turn, s√°t th∆∞∆°ng thu·∫ßn +12%"}, desc:"ATK +17, SPD +1." },
    void_sunder:  { id:"void_sunder", name:"H∆∞ V√¥ ƒêao", type:"weapon", rarity:"legendary", price:10000, atk: 55, spd:3, passive:{kind:"execute", dmg:0.28, crit:0.15, vsEnraged:0.35, note:"+28% dmg, +15% crit, th√™m +35% vs cu·ªìng n·ªô"}, desc:"ATK +28, SPD +3." },

    cloth:   { id:"cloth", name:"√Åo V·∫£i", type:"armor", rarity:"common", price:120, def:3, desc:"DEF +3." },
    leather: { id:"leather", name:"Gi√°p Da", type:"armor", rarity:"common", price:240, def:6, desc:"DEF +6." },
    chain:   { id:"chain", name:"Gi√°p X√≠ch", type:"armor", rarity:"rare", price:560, def: 14, passive:{kind:"guard", reduce:0.10, note:"Gi·∫£m 10% s√°t th∆∞∆°ng nh·∫≠n"}, desc:"DEF +10." },
    robe:    { id:"robe", name:"√Åo Cho√†ng Ph√°p", type:"armor", rarity:"rare", price:640, def: 12, mp:4, passive:{kind:"mana", mp:8, mpCost:0.10, note:"MP +8 (·∫©n), gi·∫£m 10% ti√™u hao MP"}, desc:"DEF +8, MP +4." },
    dragon_mail:{ id:"dragon_mail", name:"Long Gi√°p", type:"armor", rarity:"legend", price:2100, def: 30, passive:{kind:"barrier", shield:0.20, reduce:0.18, note:"Khi v√†o battle t·∫°o khi√™n 20% HP, gi·∫£m 18% dmg"}, desc:"DEF +18." },
    void_aegis: { id:"void_aegis", name:"H∆∞ V√¥ Gi√°p", type:"armor", rarity:"legendary", price:10000, def: 55, passive:{kind:"aegis", reduce:0.35, reflect:0.06, note:"Gi·∫£m 35% dmg, ph·∫£n 6%"}, desc:"DEF +26." },

    crown_null: { id:"crown_null", name:"V∆∞∆°ng Mi·ªán T·∫≠n Di·ªát", type:"artifact", rarity:"legendary", price:10000, desc:"+6 t·∫•t c·∫£ stat (passive)." },

    ma_cuong_robe: { id:"ma_cuong_robe", name:"√Åo Ch·ªâ Ma C∆∞∆°ng", type:"armor", rarity:"legendary", price:0, def:40, hp:60,
      desc:"DEF +40, HP +60. Hi·ªáu ·ª©ng: gi·∫£m 25% s√°t th∆∞∆°ng nh·∫≠n v√†o khi m·∫∑c." },
    hero_will: { id:"hero_will", name:"√ù Ch√≠ Anh H√πng", type:"artifact", rarity:"legendary", price:0,
      desc:"+8 t·∫•t c·∫£ stat. Hi·ªáu ·ª©ng: m·ªói tr·∫≠n 1 l·∫ßn, n·∫øu s·∫Øp ch·∫øt s·∫Ω s·ªëng l·∫°i 1 HP + Guard." },

    // === Tensura (Slime) Pack Items (inspired) ===
    scroll_predator: { id:"scroll_predator", name:"Cu·ªôn K·ªπ NƒÉng: Predator", type:"consumable", rarity:"legendary", price:0,
      desc:"H·ªçc k·ªπ nƒÉng Predator (K·∫ª Nu·ªët).", eff:{learnSkillId:"ts_predator"} },
    scroll_great_sage: { id:"scroll_great_sage", name:"Cu·ªôn K·ªπ NƒÉng: Great Sage", type:"consumable", rarity:"legendary", price:0,
      desc:"H·ªçc k·ªπ nƒÉng Great Sage (ƒê·∫°i Hi·ªÅn Tri).", eff:{learnSkillId:"ts_great_sage"} },
    scroll_demon_lord_haki: { id:"scroll_demon_lord_haki", name:"Cu·ªôn K·ªπ NƒÉng: Ma V∆∞∆°ng B√° Kh√≠", type:"consumable", rarity:"legend", price:0,
      desc:"H·ªçc k·ªπ nƒÉng Ma V∆∞∆°ng B√° Kh√≠.", eff:{learnSkillId:"ts_demon_lord_haki"} },
    scroll_beelzebuth: { id:"scroll_beelzebuth", name:"Cu·ªôn Ultimate: Beelzebuth", type:"consumable", rarity:"legendary", price:0,
      desc:"H·ªçc ultimate Beelzebuth.", eff:{learnSkillId:"ts_beelzebuth"} },
    scroll_uriel: { id:"scroll_uriel", name:"Cu·ªôn Ultimate: Uriel", type:"consumable", rarity:"legendary", price:0,
      desc:"H·ªçc ultimate Uriel.", eff:{learnSkillId:"ts_uriel"} },
    scroll_megido: { id:"scroll_megido", name:"Cu·ªôn Ultimate: Megiddo", type:"consumable", rarity:"legendary", price:0,
      desc:"H·ªçc ultimate Megiddo.", eff:{learnSkillId:"ts_megido"} },

    tempest_emblem: { id:"tempest_emblem", name:"Huy Hi·ªáu Tempest", type:"artifact", rarity:"legend", price:0,
      desc:"+4 t·∫•t c·∫£ stat (passive).", eff:{} },

  };
  const itemMeta = (id)=> ITEM_DB[id] || null;

  const GACHA_TIERS = {
    legendary: ["void_sunder", "void_aegis", "crown_null"],
    legend: ["dragonblade", "archmage_staff", "dragon_mail"],
    rare: ["steel_sword", "rune_dagger", "chain", "robe"],
    common: ["iron_sword", "wooden_sword", "leather", "cloth", "ore", "hi_potion", "hi_ether"],
    trash: ["potion", "ether"]
  };
  // Tensura pack: th√™m v√†i v·∫≠t ph·∫©m/scroll v√†o gacha (kh√¥ng ph√° t·ªâ l·ªá tier)
  try{
    GACHA_TIERS.legendary.push("scroll_predator","scroll_great_sage","scroll_beelzebuth","scroll_uriel","scroll_megido");
    GACHA_TIERS.legend.push("scroll_demon_lord_haki","tempest_emblem");
  }catch(_){}

  function hasLuckBuff(){ return (game.player.buffs?.luckTurns||0) > 0; }

  function rollGachaTier(){
    let r = randInt(1, 1_000_000);
    // Luck Elixir: tƒÉng c∆° h·ªôi ra ƒë·ªì x·ªãn
    if(hasLuckBuff()) r = Math.floor(r * 0.55);
    if(game.player._special?.locUnlucky) r = Math.floor(r * (1 + game.player._special.locUnlucky));
    if(r <= 1_000) return "legendary";           // 0.1%
    if(r <= 11_000) return "legend";             // +1.0%
    if(r <= 41_000) return "rare";               // +3.0%
    if(r <= 200_000) return "common";            // +15.9%
    return "trash";                              // 80%
  }

  const WORLD_EVENTS = [
    { id:"hero_ambush", name:"Anh h√πng t·∫≠p k√≠ch", hint:"M·ªôt nh√≥m anh h√πng hi·ªÉu l·∫ßm v√† t·∫•n c√¥ng b·∫°n.",
      enemy:(pLv)=>({ name:"Anh H√πng L∆∞u ƒê·ªông", tier:"boss", level: Math.max(8, pLv+6),
                      hp: 80 + pLv*18, atk: 12 + pLv*3, def: 8 + pLv*2, spd: 7 + Math.floor(pLv*0.8),
                      lootGold:[120,220], xp: 80 + pLv*12, enraged:false }) },
    { id:"demon_raid", name:"Ma t·ªôc t·∫≠p k√≠ch", hint:"L≈© ma t·ªôc tr√†n qua khu ph·ªë. B·∫°n b·ªã cu·ªën v√†o.",
      enemy:(pLv)=>({ name:"Ma T·ªôc Ti√™n Phong", tier:"boss", level: Math.max(10, pLv+8),
                      hp: 110 + pLv*22, atk: 14 + pLv*3, def: 10 + pLv*2, spd: 6 + Math.floor(pLv*0.7),
                      lootGold:[160,280], xp: 110 + pLv*14, enraged:false }) },
    { id:"demon_king", name:"ƒê√°nh Ma V∆∞∆°ng", hint:"Ma V∆∞∆°ng xu·∫•t hi·ªán. Kh√¥ng th·ªÉ tr√°nh.",
      enemy:(pLv)=>({ name:"Ma V∆∞∆°ng", tier:"boss", level: Math.max(20, pLv+14),
                      hp: 220 + pLv*35, atk: 18 + pLv*4, def: 14 + pLv*3, spd: 7 + Math.floor(pLv*0.8),
                      lootGold:[260,420], xp: 220 + pLv*18, enraged:false }) },
  ];
  function maybeTriggerWorldEvent(){
    if(game.gameOver || game.battle.active) return null;
    if(game.mode.kind !== "free") return null;
    const p = Math.random();
    if(p < 0.06) return WORLD_EVENTS[0];
    if(p < 0.08) return WORLD_EVENTS[1];
    if(p < 0.082) return WORLD_EVENTS[2];
    return null;
  }

  const game = {
    started:false,
    gameOver:false,
    turn:0,
    actionInTurn:0,
    story:{ seed:"", prologue:"", goal:"", twist:"", nemesis:"" },
    player:{
      name:"K·∫ª Ngo√†i L·ªÅ",
      age:18,
      level:1,
      exp:0,
      gold:120,
      stamina:100,
      maxStamina:100,
      professionId:"prof_0",
      location:"Th√†nh ph·ªë ƒê·∫°o T·∫∑c",
      raceId:"human",
      maxAge: 90,
      raceRerollsLeft:3,
      souls:0,
      predatorStacks:0,
      namedTitle:null,
      learnedSkills: [],
      skillSlots: [null,null,null,null],
      passives: [],
      weaknessId: null,
      buffs:{ luckTurns:0 },
      forcedLaborTurns: 0,
      kidneyDebuff: false,
      baseStart: {HP:20, MP:8, STR:6, DEX:6, INT:6, CHA:6, LUK:6, DEF:3},
      base:{HP:20, MP:8, STR:6, DEX:6, INT:6, CHA:6, LUK:6, DEF:3},
      stats:{HP:20, MP:8, STR:6, DEX:6, INT:6, CHA:6, LUK:6, DEF:3},
      max:{HP:20, MP:8},
      blessings:[],
      inv:[],
      equipped:{weaponUid:null, armorUid:null},
      quests:{ active:[], completed:0 },
      party:[],
    },
    world:{ heat:12, npcs:[], hiddenEvents:0, heroNpc:null,
      empire:{level:1, citizens:5, fame:0, buildings:{hall:1, housing:0, market:0, barracks:0, lab:0}},
      lastDefeated:null,
      shop:{level:0, lastRefreshTurn:-1, stock:[]}
    },
    mode:{kind:"free", hint:"T·ª± do phi√™u l∆∞u."},
    dungeon:{active:false, name:"", floor:0, maxFloor:0},
    trial:{active:false, godId:"rain", floor:0, maxFloor:50, progress:{}},
    awaitingNext:null,
    battle:{
      active:false,
      enemy:null,
      enemyHP:0,
      enemyMaxHP:0,
      turn:"player",
      guard:false,
      shieldHP:0,
      statuses:{},
      enemyStatuses:{},
      cds:{},
      log:[],
      heroWillUsed:false,
      context:null,
    },
    gamble:{choice:null},
    log:[],
  };

  const $statusLine = document.getElementById("statusLine");
  const $hud = document.getElementById("hud");
  const $story = document.getElementById("story");
  const $help = document.getElementById("help");
  const $log = document.getElementById("log");

  const $lv = document.getElementById("lv");
  const $xp = document.getElementById("xp");
  const $age = document.getElementById("age");
  const $gold = document.getElementById("gold");
  const $souls = document.getElementById("souls");
  const $race = document.getElementById("race");
  const $raceBonus = document.getElementById("raceBonus");
  const $job = document.getElementById("job");
  const $jobBonus = document.getElementById("jobBonus");
  const $ultimate = document.getElementById("ultimate");
  const $ultimateDesc = document.getElementById("ultimateDesc");
  const $blessCount = document.getElementById("blessCount");
  const $shopLevel = document.getElementById("shopLevel");
  const $turn = document.getElementById("turn");
  const $ap = document.getElementById("ap");
  const $stamina = document.getElementById("stamina");
  const $staminaHint = document.getElementById("staminaHint");
  const $mode = document.getElementById("mode");
  const $modeHint = document.getElementById("modeHint");

  const $battleUI = document.getElementById("battleUI");
  const $battleBar = document.getElementById("battleBar");
  const $skills = document.getElementById("skills");
  const $fxSlash = document.getElementById("fxSlash");

  const $overlayCreate = document.getElementById("overlayCreate");
  const $btnStart = document.getElementById("btnStart");
  const $btnRerollAll = document.getElementById("btnRerollAll");
  const $btnRerollRace = document.getElementById("btnRerollRace");
  const $nameInput = document.getElementById("nameInput");
  const $tagAge = document.getElementById("tagAge");
  const $tagLocation = document.getElementById("tagLocation");
  const $tagNPC = document.getElementById("tagNPC");
  const $raceTag = document.getElementById("raceTag");
  const $racePerk = document.getElementById("racePerk");
  const $jobTag = document.getElementById("jobTag");
  const $jobPerk = document.getElementById("jobPerk");
  const $ultTag = document.getElementById("ultTag");
  const $ultPerk = document.getElementById("ultPerk");
  const $bonusTags = document.getElementById("bonusTags");

  const $stHP = document.getElementById("stHP");
  const $stMP = document.getElementById("stMP");
  const $stSTR = document.getElementById("stSTR");
  const $stDEX = document.getElementById("stDEX");
  const $stINT = document.getElementById("stINT");
  const $stCHA = document.getElementById("stCHA");
  const $stLUK = document.getElementById("stLUK");
  const $stDEF = document.getElementById("stDEF");

  const $overlayShop = document.getElementById("overlayShop");
  const $btnCloseShop = document.getElementById("btnCloseShop");
  const $btnTipShop = document.getElementById("btnTipShop");
  const $shopList = document.getElementById("shopList");
  const $shopkeeperLine = document.getElementById("shopkeeperLine");
  const $shopLevelTag = document.getElementById("shopLevelTag");
  const $shopTipCostTag = document.getElementById("shopTipCostTag");

  const $overlayForge = document.getElementById("overlayForge");
  const $btnCloseForge = document.getElementById("btnCloseForge");
  const $forgeList = document.getElementById("forgeList");
  const $forgeDetail = document.getElementById("forgeDetail");
  const $btnForgeDo = document.getElementById("btnForgeDo");
  const $btnForgeRefresh = document.getElementById("btnForgeRefresh");
  const $forgeHint = document.getElementById("forgeHint");

  const $overlayTrial = document.getElementById("overlayTrial");
  const $trialModeSelect = document.getElementById("trialModeSelect");
  const $trialGodBlock = document.getElementById("trialGodBlock");
  const $trialHeroBlock = document.getElementById("trialHeroBlock");
  const $heroTrialTags = document.getElementById("heroTrialTags");
  const $heroTrialProgress = document.getElementById("heroTrialProgress");

  const $overlayGamble = document.getElementById("overlayGamble");
  const $overlayEmpire = document.getElementById("overlayEmpire");
  const $overlayParty = document.getElementById("overlayParty");
  const $overlayRecruit = document.getElementById("overlayRecruit");
  const $empireSummary = document.getElementById("empireSummary");
  const $empireBuildings = document.getElementById("empireBuildings");
  const $btnCloseEmpire = document.getElementById("btnCloseEmpire");
  const $btnEmpireCollect = document.getElementById("btnEmpireCollect");
  const $btnOpenParty = document.getElementById("btnOpenParty");
  const $btnCloseParty = document.getElementById("btnCloseParty");
  const $partySummary = document.getElementById("partySummary");
  const $partyList = document.getElementById("partyList");
  const $btnCloseRecruit = document.getElementById("btnCloseRecruit");
  const $btnRecruitConfirm = document.getElementById("btnRecruitConfirm");
  const $recruitInfo = document.getElementById("recruitInfo");
  const $recruitName = document.getElementById("recruitName");
  const $recruitResult = document.getElementById("recruitResult");
  const $btnCloseGamble = document.getElementById("btnCloseGamble");
  const $gambleBet = document.getElementById("gambleBet");
  const $btnGambleRoll = document.getElementById("btnGambleRoll");
  const $btnGambleEven = document.getElementById("btnGambleEven");
  const $btnGambleOdd = document.getElementById("btnGambleOdd");
  const $gambleChoiceTag = document.getElementById("gambleChoiceTag");
  const $gambleAnimText = document.getElementById("gambleAnimText");
  const $gambleResult = document.getElementById("gambleResult");

  const $btnCloseTrial = document.getElementById("btnCloseTrial");
  const $trialSelect = document.getElementById("trialSelect");
  const $trialTags = document.getElementById("trialTags");
  const $btnStartTrial = document.getElementById("btnStartTrial");
  const $trialProgress = document.getElementById("trialProgress");

  const $overlayGacha = document.getElementById("overlayGacha");
  const $btnCloseGacha = document.getElementById("btnCloseGacha");
  const $btnGacha1 = document.getElementById("btnGacha1");
  const $btnGacha10 = document.getElementById("btnGacha10");
  const $gachaStatus = document.getElementById("gachaStatus");
  const $gachaReveal = document.getElementById("gachaReveal");
  const $btnGachaOk = document.getElementById("btnGachaOk");

  const $overlayMenu = document.getElementById("overlayMenu");
  const $btnCloseMenu = document.getElementById("btnCloseMenu");
  const $menuGrid = document.getElementById("menuGrid");
  const $menuChips = document.getElementById("menuChips");
  const $menuHint = document.getElementById("menuHint");
  const $btnMenu = document.getElementById("btnMenu");


// Close all overlays to avoid stacked overlays blocking buttons
const OVERLAY_IDS = [
  "overlayCreate","overlayMenu","overlayShop","overlayForge","overlayTrial","overlayGacha","overlayTalk",
  "overlaySkills","overlayInv","overlayPassives","overlayProfession",
  "overlayGamble","overlayTravel","overlayEmpire","overlayParty","overlayRecruit"
];
function closeAllOverlays(exceptId=null){
  for(const id of OVERLAY_IDS){
    if(exceptId && id===exceptId) continue;
    const el = document.getElementById(id);
    if(el) el.style.display = "none";
  }
}
function showOverlay(id){
  closeAllOverlays(id);
  const el = document.getElementById(id);
  if(el) el.style.display = "flex";
}

  const $overlayTalk = document.getElementById("overlayTalk");
  const $btnCloseTalk = document.getElementById("btnCloseTalk");
  const $talkInput = document.getElementById("talkInput");
  const $btnTalkSend = document.getElementById("btnTalkSend");

  const $overlaySkills = document.getElementById("overlaySkills");
  const $btnCloseSkills = document.getElementById("btnCloseSkills");
  const $skillSlotsWrap = document.getElementById("skillSlotsWrap");
  const $skillListWrap = document.getElementById("skillListWrap");

  const $overlayInv = document.getElementById("overlayInv");
  const $overlayPassives = document.getElementById("overlayPassives");
  const $overlayProfession = document.getElementById("overlayProfession");
  const $passiveListWrap = document.getElementById("passiveListWrap");
  const $weaknessWrap = document.getElementById("weaknessWrap");
  const $professionWrap = document.getElementById("professionWrap");
  const $cinematic = document.getElementById("cinematic");
  const $cinTitle = document.getElementById("cinTitle");
  const $cinSub = document.getElementById("cinSub");
  const $btnCloseInv = document.getElementById("btnCloseInv");
  const $invBody = document.getElementById("invBody");

  function addLog(html){
    game.log.unshift({html, t: nowTag()});
    if(game.log.length > 80) game.log.pop();
  }
  function pushStory(text){
    const sep = $story.textContent ? "\n\n" : "";
    $story.textContent += sep + text;
    $story.scrollTop = $story.scrollHeight;
  }
  function playSlash(){
    $fxSlash.classList.remove("play");
    void $fxSlash.offsetWidth;
    $fxSlash.classList.add("play");
  }
  function shake(el){
    el.classList.remove("shake");
    void el.offsetWidth;
    el.classList.add("shake");
  }

  function makeNPC(){
    const nameA = ["An","B·∫£o","Chi","D≈©ng","Eri","Fang","Gia","H√†","Khoa","Linh","My","Nam","Oanh","Ph√∫c","Qu√¢n","T√∫","Uy√™n","V≈©"];
    const nameB = ["Lam","Minh","Ng·ªçc","Qu·ª≥nh","S∆°n","Th·∫£o","Thi√™n","Tr√∫c","V√¢n","Vy","Long","Khang","T√¢m","Huy","Tuy·∫øt"];
    const name = pick(nameA) + " " + pick(nameB);
    const role = pick(NPC_ROLES);
    const traits = [...NPC_TRAITS].sort(()=>Math.random()-0.5).slice(0, randInt(2,3));
    const stats = { empathy: randInt(0, 100), greed: randInt(0, 100), temper: randInt(0, 100), courage: randInt(0, 100), cunning: randInt(0, 100), mood: randInt(-10, 10) };
    return { id: uid(), name, role, traits, stats, location: pick(LOCATIONS), rel: randInt(-5, 5), eventStage: 0 };
  }
  function ensureNPCs(){ while(game.world.npcs.length < 12) game.world.npcs.push(makeNPC()); }
  function currentNPC(){
    ensureNPCs();
    let pool = game.world.npcs.filter(n=>n.location===game.player.location);
    if(pool.length) return pick(pool);
    const n = makeNPC(); n.location = game.player.location; game.world.npcs.push(n); return n;
  }
  function runHiddenSideEvents(){
    ensureNPCs();
    const count = randInt(1, 3);
    for(let i=0;i<count;i++){
      const n = pick(game.world.npcs);
      const k = pick(["empathy","greed","temper","courage","cunning","mood"]);
      const delta = randInt(-3, 3);
      n.stats[k] = clamp(n.stats[k] + delta, -50, 110);
      if(Math.random() < 0.10) n.location = pick(LOCATIONS);
      game.world.hiddenEvents += 1;
    }

    // (B√™n l·ªÅ) C√≥ t·ªâ l·ªá NPC nh·∫≠n Ph∆∞·ªõc L√†nh Anh H√πng
    if(!game.world.heroNpc && Math.random() < 0.015){
      const n2 = pick(game.world.npcs);
      game.world.heroNpc = {name: n2.name};
      pushStory(`‚ö†Ô∏è Tin ƒë·ªìn: <b>${n2.name}</b> ƒë√£ nh·∫≠n <b>Ph∆∞·ªõc L√†nh Anh H√πng</b>!`);
      addLog(`NPC nh·∫≠n ph∆∞·ªõc anh h√πng: <b>${n2.name}</b>.`);
    }
  }

  const getStacks = ()=> game.player.inv.filter(x=>x.kind==="stack");
  const getGears = ()=> game.player.inv.filter(x=>x.kind==="gear");
  const stackQty = (id)=> (getStacks().find(x=>x.id===id)?.qty || 0);
  function addStack(id, qty){
    const it = getStacks().find(x=>x.id===id);
    if(it) it.qty += qty;
    else game.player.inv.push({kind:"stack", id, qty});
  }
  function removeStack(id, qty){
    const it = getStacks().find(x=>x.id===id);
    if(!it || it.qty < qty) return false;
    it.qty -= qty;
    if(it.qty <= 0) game.player.inv = game.player.inv.filter(x=>!(x.kind==="stack" && x.id===id));
    return true;
  }
  function addGear(id, enh=0){ game.player.inv.push({kind:"gear", uid:uid(), id, enh}); }
  function findGearByUid(gearUid){ return getGears().find(g=>g.uid===gearUid) || null; }
  function hasArtifact(id){ return getStacks().some(x=>x.id===id && x.qty>0); }

  const MAX_LV = Infinity;
  function expNeeded(lv){ return Math.floor(70 + 45 * Math.pow(lv, 1.35)); }
  function passiveMult(type){
    let mult = 1.0;
    for(const pid of game.player.passives){
      const ps = passiveById(pid);
      if(!ps) continue;
      if(ps.type===type) mult += ps.val;
    }
    return mult;
  }
  function grantExp(amount){
    if(amount <= 0) return;
    let total = Math.floor(amount * 4.0 * passiveMult("exp"));
    game.player.exp += total;
    addLog(`Nh·∫≠n <b>+${total} EXP</b>.`);

    if(hasArtifact("hero_will")){
      const bonus = Math.floor(total * 0.15);
      game.player.exp += bonus;
      addLog(`√ù Ch√≠ Anh H√πng: bonus <b>+${bonus} EXP</b>.`);
    }

    while(game.player.exp >= expNeeded(game.player.level)){
      game.player.exp -= expNeeded(game.player.level);
      game.player.level += 1;
      game.player.base.HP += 6;
      game.player.base.MP += 2;
      game.player.base.STR += 1;
      game.player.base.DEX += 1;
      game.player.base.INT += 1;
      game.player.base.CHA += 1;
      game.player.base.LUK += 1;
      game.player.base.DEF += 1;
      computeStats(true);
      addLog(`<b>LEVEL UP!</b> B·∫°n l√™n Lv ${game.player.level}.`);
      pushStory(`=== LEVEL UP ===\nB·∫°n l√™n Lv ${game.player.level}!\nBase stat tƒÉng v√† HP/MP h·ªìi ƒë·∫ßy.`);
    }

    if(game.player.level >= MAX_LV){
      game.player.exp = Math.min(game.player.exp, expNeeded(MAX_LV)-1);
    }
  }

  // Ma V∆∞∆°ng th·∫Øng: reset to√†n b·ªô level v√† stat ƒë√£ c·ªông theo level
  function resetProgressAfterDemonKing(){
    const p = game.player;
    const base0 = p.baseStart ? {...p.baseStart} : {HP:20, MP:8, STR:6, DEX:6, INT:6, CHA:6, LUK:6, DEF:3};
    p.level = 1;
    p.exp = 0;
    p.base = {...base0};
    p.stats = {...p.base};
    computeStats(true);
  }

  // Gi·∫£m level (d√πng cho passive H·ªßy Di·ªát)
  function levelDown(n=1){
    const p = game.player;
    for(let i=0;i<n;i++){
      if(p.level <= 1) break;
      p.level -= 1;
      p.exp = 0;
      p.base.HP -= 6;
      p.base.MP -= 2;
      p.base.STR -= 1;
      p.base.DEX -= 1;
      p.base.INT -= 1;
      p.base.CHA -= 1;
      p.base.LUK -= 1;
      p.base.DEF -= 1;
    }
    // kh√¥ng gi·∫£m d∆∞·ªõi m·ª©c kh·ªüi ƒëi·ªÉm
    p.base.HP = Math.max(p.baseStart?.HP||20, p.base.HP);
    p.base.MP = Math.max(p.baseStart?.MP||8, p.base.MP);
    p.base.STR = Math.max(p.baseStart?.STR||6, p.base.STR);
    p.base.DEX = Math.max(p.baseStart?.DEX||6, p.base.DEX);
    p.base.INT = Math.max(p.baseStart?.INT||6, p.base.INT);
    p.base.CHA = Math.max(p.baseStart?.CHA||6, p.base.CHA);
    p.base.LUK = Math.max(p.baseStart?.LUK||6, p.base.LUK);
    p.base.DEF = Math.max(p.baseStart?.DEF||3, p.base.DEF);
    computeStats(true);
  }

  function stealOneComponentFromPlayer(enemy){
    const p = game.player;
    const opts = [];
    if(p.learnedSkills && p.learnedSkills.length) opts.push("skill");
    if(p.passives && p.passives.length) opts.push("passive");
    if(p.inv && p.inv.length) opts.push("item");
    if(p.level && p.level > 1) opts.push("level");
    if(!opts.length) return null;

    const kind = pick(opts);
    enemy.stolen = enemy.stolen || {skills:[], passives:[], items:[], levels:0};

    if(kind==="skill"){
      const sid = pick(p.learnedSkills);
      p.learnedSkills = p.learnedSkills.filter(x=>x!==sid);
      // remove from slots
      for(let i=0;i<4;i++) if(p.skillSlots[i]===sid) p.skillSlots[i]=null;
      enemy.stolen.skills.push(sid);
      return {kind, name: (skillById(sid)?.name || sid)};
    }
    if(kind==="passive"){
      const pid = pick(p.passives);
      p.passives = p.passives.filter(x=>x!==pid);
      enemy.stolen.passives.push(pid);
      return {kind, name: (passiveById(pid)?.name || pid)};
    }
    if(kind==="item"){
      const it = pick(p.inv);
      // x√≥a ƒë√∫ng 1 stack qty ho·∫∑c 1 gear
      if(it.kind==="stack"){
        it.qty = (it.qty||0) - 1;
        if(it.qty <= 0) p.inv = p.inv.filter(x=>x!==it);
        enemy.stolen.items.push({kind:"stack", id:it.id});
        return {kind, name: (itemMeta(it.id)?.name || it.id)};
      }else{
        // gear
        // n·∫øu ƒëang equip th√¨ th√°o
        if(p.equipped.weaponUid===it.uid) p.equipped.weaponUid=null;
        if(p.equipped.armorUid===it.uid) p.equipped.armorUid=null;
        p.inv = p.inv.filter(x=>x!==it);
        enemy.stolen.items.push({kind:"gear", id:it.id});
        return {kind, name: (itemMeta(it.id)?.name || it.id)};
      }
    }
    if(kind==="level"){
      levelDown(1);
      enemy.stolen.levels += 1;
      return {kind, name:"1 Level"};
    }
    return null;
  }

  // Pre-check + spend stamina for an action
  function preAction(cost=1, label="h√†nh ƒë·ªông"){
    if(!game.started || game.gameOver) return false;
    computeStats(false);

    // Trong chi·∫øn ƒë·∫•u: kh√¥ng b·ªã tr·ª´ th·ªÉ l·ª±c, kh√¥ng y√™u c·∫ßu ƒë·ªß th·ªÉ l·ª±c
    if(game.battle.active) return true;

    // B·ªã b·∫Øt l√†m n√¥ d·ªãch: ch·ªâ ƒë∆∞·ª£c ki·∫øm ti·ªÅn, th·ªÉ l·ª±c hao g·∫•p ƒë√¥i
    if(game.player.forcedLaborTurns && game.player.forcedLaborTurns > 0){
      if(label !== "ki·∫øm ti·ªÅn" && label !== "ngh·ªâ"){
        pushStory("‚õèÔ∏è B·∫°n ƒëang b·ªã b·∫Øt l√†m <b>n√¥ d·ªãch</b> (2 turn). B·∫°n ch·ªâ c√≥ th·ªÉ <b>ki·∫øm ti·ªÅn</b> ho·∫∑c <b>Rest</b>.");
        addLog("‚õèÔ∏è N√¥ d·ªãch: ch·ªâ ƒë∆∞·ª£c ki·∫øm ti·ªÅn ho·∫∑c ngh·ªâ.");
        renderAll();
        return false;
      }
      cost = cost * 2;
    }

    if(game.player.stamina < cost){
      pushStory(`
B·∫°n qu√° m·ªát ƒë·ªÉ ${label}. (Th·ªÉ l·ª±c ${game.player.stamina}/${game.player.maxStamina})
H√£y ch·ªçn <b>Rest</b> ƒë·ªÉ h·ªìi th·ªÉ l·ª±c.`);
      addLog(`<b>Thi·∫øu th·ªÉ l·ª±c</b> ƒë·ªÉ ${label}.`);
      renderAll();
      return false;
    }
    game.player.stamina = clamp(game.player.stamina - cost, 0, game.player.maxStamina);
    return true;
  }

  function doRest(){
    if(game.battle.active){ pushStory("Kh√¥ng th·ªÉ <b>Rest</b> trong chi·∫øn ƒë·∫•u."); addLog("Rest b·ªã ch·∫∑n trong combat."); renderAll(); return; }
    if(!game.started || game.gameOver) return;
    if(!preAction(0, "ngh·ªâ")) return;
    computeStats(false);
    game.player.stamina = game.player.maxStamina;
    game.player.stats.HP = clamp(game.player.stats.HP + Math.floor(game.player.max.HP*0.25), 0, game.player.max.HP);
    game.player.stats.MP = clamp(game.player.stats.MP + Math.floor(game.player.max.MP*0.25), 0, game.player.max.MP);
    // H·ªìi ƒë·ªìng ƒë·ªôi n·∫øu c√≥
    if(game.player.party && game.player.party.length){
      for(const a of game.player.party){ a.hp = a.maxHp; }
    }
    pushStory(`\nB·∫°n ngh·ªâ ng∆°i, h·ªìi ƒë·∫ßy <b>th·ªÉ l·ª±c</b> v√† h·ªìi 25% HP/MP.`);
    addLog(`<b>Rest</b>: h·ªìi th·ªÉ l·ª±c.`);
    countAction();
    renderAll();
  }

  // Manual Save/Load (localStorage)
  const SAVE_KEY = "command_rpg_save_v7";
  const SAVE_VER = 22;
  function hashFNV1a(str){
    // FNV-1a 32-bit (nh·∫π, ƒë·ªß ƒë·ªÉ ph√°t hi·ªán s·ª≠a save c∆° b·∫£n)
    let h = 0x811c9dc5;
    for(let i=0;i<str.length;i++){
      h ^= str.charCodeAt(i);
      h = Math.imul(h, 0x01000193) >>> 0;
    }
    return ("00000000" + h.toString(16)).slice(-8);
  }

  const SAVE_SECRET = "v15_secret_" + "f8" + "a3" + "7c"; // c·ªë t√¨nh t√°ch chu·ªói ƒë·ªÉ kh√≥ s·ª≠a b·∫±ng tay h∆°n ch√∫t
  function computeCodeFingerprint(){
    try{
      // N·∫øu b·∫°n s·ª≠a code (c√°c h√†m c·ªët l√µi) => fingerprint ƒë·ªïi => save b·ªã xo√°
      const blob =
        String(openGachaMulti) +
        String(npcReplyAndEvent) +
        String(endBattle) +
        String(doMoney) +
        String(saveGame) +
        String(loadGame);
      return hashFNV1a(blob);
    }catch(e){
      return "00000000";
    }
  }

  function saveGame(){
    try{
      ensureQuests();
      // L∆∞u game d·∫°ng thu·∫ßn ƒë·ªÉ t∆∞∆°ng th√≠ch t·ªëi ƒëa (kh√¥ng anti-cheat)
      localStorage.setItem(SAVE_KEY, JSON.stringify(game));
      addLog("<b>ƒê√£ l∆∞u</b> (Save).");
      pushStory(`
‚úÖ ƒê√£ l∆∞u game.`);
    }catch(e){
      addLog("<b>L∆∞u th·∫•t b·∫°i</b>.");
      pushStory(`
‚ùå L∆∞u th·∫•t b·∫°i: ${e?.message||e}`);
    }
    renderAll();
  }

  function wipeSave(reason){
    // Anti-cheat ƒë√£ b·ªã g·ª° b·ªè theo y√™u c·∫ßu (kh√¥ng t·ª± xo√° save)
    pushStory(`
‚ö†Ô∏è (Anti-cheat ƒë√£ t·∫Øt) ${reason || ""}`.trim());
    addLog(`‚ö†Ô∏è (Anti-cheat ƒë√£ t·∫Øt) ${reason || ""}`.trim());
  }

  function loadGame(){
    try{
      const raw = localStorage.getItem(SAVE_KEY);
      if(!raw){
        pushStory(`
Kh√¥ng c√≥ save ƒë·ªÉ load.`);
        addLog("Load: kh√¥ng c√≥ save.");
        renderAll();
        return;
      }
      const parsed = JSON.parse(raw);

      // H·ªó tr·ª£ c·∫£ save thu·∫ßn (game object) v√† wrapper c≈© (c√≥ .data)
      const saved = (parsed && typeof parsed === "object" && parsed.data) ? parsed.data : parsed;

      if(saved && typeof saved === "object" && saved.player && saved.world){
        for(const k of Object.keys(saved)) game[k] = saved[k];
      }else{
        // N·∫øu save l·ªói c√∫ ph√°p/kh√¥ng ƒë√∫ng c·∫•u tr√∫c th√¨ ch·ªâ b√°o l·ªói, KH√îNG xo√° save t·ª± ƒë·ªông
        pushStory(`
‚ùå Save kh√¥ng h·ª£p l·ªá (kh√¥ng t·ª± xo√°).`);
        addLog("Load: save kh√¥ng h·ª£p l·ªá.");
        renderAll();
        return;
      }

      // back-compat / defaults
      game.player.stamina ??= 10;
      game.player.maxStamina ??= 10;
      // Fix: kh√¥ng gi·ªØ "ng·∫´u nhi√™n" hi·ªán t·∫°i khi save c≈© thi·∫øu ngh·ªÅ
      const _sp = (saved && saved.player) ? saved.player : {};
      game.player.professionId = _sp.professionId || _sp.jobId || _sp.profession || "prof_0";
      game.player.location ??= "Th√†nh ph·ªë ƒê·∫°o T·∫∑c";
      learnSkill("basic_attack");
      ensureNPCs();
      ensureQuests();
      ensureTensuraState();
      // UI: tr√°nh overlay ch·ªìng l√†m n√∫t kh√¥ng b·∫•m ƒë∆∞·ª£c sau khi load
      closeAllOverlays(null);
      if(game.started){ $overlayCreate.style.display = "none"; }
      else { $overlayCreate.style.display = "flex"; syncCreateUI(); }
      computeStats(false);
      pushStory(`
‚úÖ ƒê√£ load game.`);
      addLog("<b>ƒê√£ load</b> (Load).");
      renderAll();
    }catch(e){
      addLog("<b>Load th·∫•t b·∫°i</b>.");
      pushStory(`
‚ùå Load th·∫•t b·∫°i: ${e?.message||e}`);
      renderAll();
    }
  }



  function applyLocationTurnTick(){
    const eff = getLocationEffect(game.player.location);
    if(game.player._special) delete game.player._special.locUnlucky;
    if(eff?.onTurn){
      eff.onTurn(game.player);
      computeStats(false);
    }
  }

function countAction(){
    if(!game.started || game.gameOver) return;
    runHiddenSideEvents();
    game.world.heat = clamp(game.world.heat + randInt(-1,2), 0, 100);

    game.actionInTurn += 1;
    if(game.actionInTurn >= 10){
      game.actionInTurn = 0;
      game.turn += 1;
      game.player.age += 1;

      // Buff: Luck Elixir (2 turn)
      if(game.player.buffs && game.player.buffs.luckTurns>0){
        game.player.buffs.luckTurns -= 1;
        if(game.player.buffs.luckTurns<=0){
          game.player.buffs.luckTurns = 0;
          addLog("<b>Luck</b> ƒë√£ h·∫øt hi·ªáu l·ª±c.");
        }
      }

      applyLocationTurnTick();

      // Tr·∫°ng th√°i: b·ªã b·∫Øt l√†m n√¥ d·ªãch ·ªü h·∫ßm m·ªè (2 turn)
      if(game.player.forcedLaborTurns && game.player.forcedLaborTurns > 0){
        game.player.forcedLaborTurns -= 1;
        game.player.gold = 0;
        addLog(`‚õèÔ∏è N√¥ d·ªãch: v√†ng b·ªã t·ªãch thu v·ªÅ 0. C√≤n ${game.player.forcedLaborTurns} turn.`);
        if(game.player.forcedLaborTurns <= 0){
          game.player.forcedLaborTurns = 0;
          addLog("‚õèÔ∏è B·∫°n ƒë∆∞·ª£c th·∫£ kh·ªèi ki·∫øp n√¥ d·ªãch.");
          pushStory("‚õèÔ∏è H·∫øt 2 turn, b·∫°n ƒë∆∞·ª£c th·∫£ kh·ªèi h·∫ßm m·ªè.");
        }
      }
      // Thu·∫ø t·∫≠n th·∫ø: m·ªói 6 turn thu 90% v√†ng
      if(game.turn % 6 === 0){
        const tax = Math.floor(game.player.gold * 0.90);
        if(tax > 0){
          game.player.gold -= tax;
          addLog(`<b>Thu·∫ø</b>: b·∫°n b·ªã thu <b>${tax} v√†ng</b> (90%).`);
        }
      }

      // Th√†nh ph·ªë ƒê·∫°o T·∫∑c: 40% b·ªã c∆∞·ªõp 1 v·∫≠t ph·∫©m trong kho (m·ªói turn)
      if(game.player.location === "Th√†nh ph·ªë ƒê·∫°o T·∫∑c" && game.player.inv.length){
        if(Math.random() < 0.40){
          const idx = randInt(0, game.player.inv.length-1);
          const it = game.player.inv.splice(idx,1)[0];
          addLog(`<b>ƒê·∫°o t·∫∑c</b> ƒë√£ c∆∞·ªõp: <b>${itemMeta(it.id)?.name || it.id}</b>!`);
          pushStory(`‚ö†Ô∏è ·ªû <b>Th√†nh ph·ªë ƒê·∫°o T·∫∑c</b>, b·∫°n b·ªã c∆∞·ªõp m·∫•t <b>${itemMeta(it.id)?.name || it.id}</b>.`);
        }
      }

      const ev = maybeTriggerWorldEvent();
      if(ev){
        game.mode = {kind:"forcedEvent", hint: ev.name};
        pushStory(`\n=== S·ª∞ KI·ªÜN B·∫ÆT BU·ªòC ===\n${ev.name}: ${ev.hint}\nB·∫°n bu·ªôc ph·∫£i tham gia chi·∫øn ƒë·∫•u!`);
        addLog(`<b>S·ª± ki·ªán b·∫Øt bu·ªôc</b>: ${ev.name}.`);
        startBattle(ev.enemy(game.player.level), {kind:"forced", eventName: ev.name});
        return;
      }

      if(game.player.age >= (game.player.maxAge || 100)){
        game.gameOver = true;
        pushStory("\n\n=== GAME OVER ===\nB·∫°n ƒë√£ h·∫øt tu·ªïi th·ªç v√† ch·∫øt gi√†.");
        addLog("<b>GAME OVER</b>: ch·∫øt gi√†.");
      }
    }
  }

  function weakness(){ return game.player.weaknessId ? WEAKNESSES.find(w=>w.id===game.player.weaknessId) : null; }

  function sumBlessingBonuses(){
    const out = {HP:0, MP:0, STR:0, DEX:0, INT:0, CHA:0, LUK:0, DEF:0};
    for(const b of game.player.blessings){
      if(b && b.bonus){
        for(const [k,v] of Object.entries(b.bonus)) out[k] = (out[k]||0) + v;
      }else if(b && b.stat){
        out[b.stat] = (out[b.stat]||0) + (b.delta||0);
      }
    }
    return out;
  }
  function applyWeaknessBase(s){
    const wk = weakness();
    if(!wk) return {s, mods:{}};
    const mods = {goldMult:1, mpCostMult:1, dmgTakenMult:1, critMult:1, hpRegenMult:1};
    for(const [k,v] of Object.entries(wk.eff)){
      if(k==="goldMult") mods.goldMult += v;
      else if(k==="mpCostMult") mods.mpCostMult += v;
      else if(k==="dmgTakenMult") mods.dmgTakenMult += v;
      else if(k==="critMult") mods.critMult += v;
      else if(k==="hpRegenMult") mods.hpRegenMult += v;
      else s[k] = (s[k]||0) + v;
    }
    return {s, mods};
  }

  function computeStats(healFull=false){
    const p = game.player;
    let s = {...p.base};

    const r = raceById(p.raceId);
    for(const [k,v] of Object.entries(r.bonus)) s[k] = (s[k]||0) + v;

    const bsum = sumBlessingBonuses();
    for(const [k,v] of Object.entries(bsum)) s[k] = (s[k]||0) + v;
    const prof = professionById(p.professionId);
    for(const [k,v] of Object.entries(prof.bonus||{})) s[k] = (s[k]||0) + v;

    if(hasArtifact("crown_null")){
      for(const k of ["STR","DEX","INT","CHA","LUK","DEF"]) s[k] += 6;
    }
    if(hasArtifact("hero_will")){
      for(const k of ["STR","DEX","INT","CHA","LUK","DEF"]) s[k] += 8;
      s.HP += 8; s.MP += 8;
    }
    if(hasArtifact("tempest_emblem")){
      for(const k of ["STR","DEX","INT","CHA","LUK","DEF"]) s[k] += 4;
      s.HP += 10; s.MP += 10;
    }

    const wkApply = applyWeaknessBase(s);
    s = wkApply.s;

    const weapon = p.equipped.weaponUid ? findGearByUid(p.equipped.weaponUid) : null;
    const armor = p.equipped.armorUid ? findGearByUid(p.equipped.armorUid) : null;
    const wMeta = weapon ? itemMeta(weapon.id) : null;
    const aMeta = armor ? itemMeta(armor.id) : null;

    let atk = 0, def = 0, spd = 0, mpBonus = 0, hpBonus = 0;
    if(wMeta){ atk += (wMeta.atk||0) + (weapon.enh||0); spd += (wMeta.spd||0); }
    if(aMeta){ def += (aMeta.def||0) + (armor.enh||0); mpBonus += (aMeta.mp||0); hpBonus += (aMeta.hp||0); }

    const maxHpMult = passiveMult("maxHP");
    const maxMpMult = passiveMult("maxMP");

    let maxHP = Math.max(10, Math.round((s.HP + hpBonus + Math.floor(s.STR*1.2) + def) * maxHpMult));
    let maxMP = Math.max(5, Math.round((s.MP + mpBonus + Math.floor(s.INT*0.9)) * maxMpMult));
    // Debuff: b·ªã m·ªï th·∫≠n ·ªü Ch·ª£ ƒê√™m (-30% gi·ªõi h·∫°n m√°u & th·ªÉ l·ª±c)
    if(p.kidneyDebuff){
      maxHP = Math.max(1, Math.floor(maxHP * 0.70));
    }

    // Stamina (th·ªÉ l·ª±c)
    const staBase = 100 + Math.floor(p.level/2);
    const staFromDex = Math.floor((s.DEX||0)/5);
    p.maxStamina = clamp(staBase + staFromDex, 50, 300);
    if(p.kidneyDebuff){ p.maxStamina = Math.max(1, Math.floor(p.maxStamina * 0.70)); }
    if(p.stamina == null) p.stamina = p.maxStamina;
    p.stamina = clamp(p.stamina, 0, p.maxStamina);

    p._derived = {
      atk, def, spd,
      mods: wkApply.mods,
      dmgMult: passiveMult("dmg"),
      critBonus: (passiveMult("crit") - 1),
      pierceBonus: (passiveMult("pierce") - 1),
      goldMult: passiveMult("gold"),
      hpRegen: 0.0,
      mpRegen: 0.0,
    };

    let hpRegen = 0, mpRegen = 0;
    for(const pid of p.passives){
      const ps = passiveById(pid);
      if(!ps) continue;
      if(ps.type==="hpRegen") hpRegen += ps.val;
      if(ps.type==="mpRegen") mpRegen += ps.val;
    }
    hpRegen *= (p._derived.mods.hpRegenMult || 1);
    p._derived.hpRegen = hpRegen;
    p._derived.mpRegen = mpRegen;

    if(healFull){
      s.HP = maxHP;
      s.MP = maxMP;
    } else {
      s.HP = clamp(p.stats.HP, 0, maxHP);
      s.MP = clamp(p.stats.MP, 0, maxMP);
    }

    p.stats = s;
    p.max = {HP: maxHP, MP: maxMP};
    p._special = { maCuongEquipped: (armor && armor.id==="ma_cuong_robe"), raphael: p.passives.includes("tp_raphael"), demonLord: p.passives.includes("tp_true_demon_lord") };
  }

  function rollStory(){
    const prologues = [
      "B·∫°n t·ªânh d·∫≠y v·ªõi m·ªôt d·∫•u ·∫•n l·∫° tr√™n tay v√† m·ªôt k√Ω ·ª©c b·ªã x√© n√°t.",
      "B·∫°n b·ªã n√©m kh·ªèi d√≤ng th·ªùi gian v√† r∆°i xu·ªëng th·∫ø gi·ªõi n√†y nh∆∞ m·ªôt l·ªói h·ªá th·ªëng.",
      "M·ªôt gi·ªçng n√≥i th·∫ßn th√°nh n√≥i r·∫±ng: 'H√£y ch·ª©ng minh gi√° tr·ªã c·ªßa ng∆∞∆°i'.",
      "B·∫°n l√† k·∫ª ngo√†i l·ªÅ, kh√¥ng thu·ªôc phe n√†o ‚Äî nh∆∞ng m·ªçi phe ƒë·ªÅu mu·ªën l·ª£i d·ª•ng b·∫°n.",
    ];
    const goals = [
      "T√¨m 'Tr√°i Tim Ma C∆∞∆°ng' ƒë·ªÉ ph√° l·ªùi nguy·ªÅn ƒëang b√†o m√≤n tu·ªïi th·ªç.",
      "Truy l√πng Ma V∆∞∆°ng Lv999 v√† c·∫Øt ƒë·ª©t chu k·ª≥ t√°i sinh c·ªßa h·∫Øn.",
      "Thu th·∫≠p 3 ph∆∞·ªõc l√†nh t·ªëi th∆∞·ª£ng ƒë·ªÉ m·ªü c·ªïng v·ªÅ nh√†.",
      "Tr·ªü th√†nh anh h√πng m·ªõi b·∫±ng c√°ch chi·∫øn th·∫Øng 50 t·∫ßng trial c·ªßa √≠t nh·∫•t 1 v·ªã th·∫ßn.",
    ];
    const twists = [
      "NPC b·∫°n tin nh·∫•t c√≥ th·ªÉ s·∫Ω ph·∫£n b·ªôi v√¨ m·ªôt m√≥n h√†ng hi·∫øm.",
      "M·ªói l·∫ßn b·∫°n quay gacha, th·∫ø gi·ªõi n√≥ng l√™n‚Ä¶ v√† qu√°i v·∫≠t m·∫°nh h∆°n.",
      "M·ªôt nh∆∞·ª£c ƒëi·ªÉm b·∫©m sinh c√≥ th·ªÉ bi·∫øn b·∫°n th√†nh con m·ªìi ƒë√∫ng l√∫c y·∫øu nh·∫•t.",
      "C√≥ nh·ªØng s·ª± ki·ªán b√™n l·ªÅ di·ªÖn ra m√† b·∫°n kh√¥ng th·∫•y, v√† ch√∫ng thay ƒë·ªïi c·∫£ th√†nh ph·ªë.",
    ];
    const nemesis = ["H·ªôi ƒê·∫°o T·∫∑c Ch·ª£ ƒê√™m","K·ªµ Sƒ© B√≥ng T·ªëi","S·ª© Gi·∫£ Sa Ng√£","Th√°nh ƒêo√†n Cu·ªìng T√≠n","Ma V∆∞∆°ng T√†n H·ªìn"];
    game.story.seed = uid();
    game.story.prologue = pick(prologues);
    game.story.goal = pick(goals);
    game.story.twist = pick(twists);
    game.story.nemesis = pick(nemesis);
  }

  function shopTipCost(level){ return 80 + Math.floor(120 * Math.pow(level+1, 1.4)); }
  function refreshShopStock(force=false){
    const shop = game.world.shop;
    if(!force && shop.lastRefreshTurn === game.turn) return;
    shop.lastRefreshTurn = game.turn;

    
    const lvl = shop.level;

    // Base items (always available). Shop level cao -> th√™m ƒë·ªì "x·ªãn" h∆°n.
    const baseStock = ["potion","ether","ore","hi_potion","hi_ether","lifepotion"];
    if(lvl >= 3) baseStock.push("luck_elixir");

    // ===== Gear quality scales with shop level =====
    const gearCommon = Object.values(ITEM_DB).filter(m=> (m.type==="weapon" || m.type==="armor") && (m.rarity==="common"));
    const gearRare   = Object.values(ITEM_DB).filter(m=> (m.type==="weapon" || m.type==="armor") && (m.rarity==="rare"));
    const gearLegend = Object.values(ITEM_DB).filter(m=> (m.type==="weapon" || m.type==="armor") && (m.rarity==="legendary"));

    const wLegend = clamp(Math.floor((lvl-2)*8), 0, 70);
    const wRare   = clamp(20 + lvl*5, 10, 60);
    const wCommon = clamp(100 - wLegend - wRare, 5, 90);

    const rollGearPool = ()=>{
      const r = Math.random()*100;
      if(r < wLegend && gearLegend.length) return gearLegend;
      if(r < (wLegend + wRare) && gearRare.length) return gearRare;
      return gearCommon.length ? gearCommon : (gearRare.length ? gearRare : gearLegend);
    };

    const gearSet = new Set();
    const nGear = clamp(2 + Math.floor(lvl/2), 2, 12);
    for(let i=0;i<nGear;i++){
      const pool = rollGearPool();
      if(!pool || pool.length===0) break;
      gearSet.add(pick(pool).id);
    }

    // ===== Stock build =====
    shop.stock = [];
    for(const id of baseStock){
      const meta = itemMeta(id); if(!meta) continue;
      const priceMul = (meta.rarity==="legendary") ? 0.95 : 0.75;
      shop.stock.push({kind:"stack", id, price: clamp(Math.floor(meta.price*priceMul), 1, 10000)});
    }
    for(const id of Array.from(gearSet)){
      const meta = itemMeta(id); if(!meta) continue;
      const mul = (meta.rarity==="legendary") ? 1.05 : (meta.rarity==="rare" ? 0.90 : 0.80);
      const basePrice = meta.price>0 ? meta.price : (meta.rarity==="legendary" ? 1200 : (meta.rarity==="rare" ? 650 : 220));
      shop.stock.push({kind:"gear", id, price: clamp(Math.floor(basePrice*mul), 1, 10000)});
    }

    // ===== Skills / passives (no player level cap; scales by shop level) =====
    const activePool = ACTIVE_SKILLS.filter(s=>s.kind==="active");
    const weightByRarity = (rar)=>{
      if(rar==="mythic") return 1 + lvl*0.35;
      if(rar==="legendary") return 1 + lvl*0.25;
      if(rar==="rare") return 1 + lvl*0.15;
      return 1;
    };
    const weightedPick = (arr, wfn)=>{
      if(!arr || arr.length===0) return null;
      let total = 0;
      for(const x of arr) total += wfn(x.rarity);
      let r = Math.random()*total;
      for(const x of arr){ r -= wfn(x.rarity); if(r<=0) return x; }
      return arr[arr.length-1];
    };

    if(activePool.length){
      const a1 = weightedPick(activePool, weightByRarity);
      if(a1) shop.stock.push({kind:"skill", id:a1.id, price: clamp(220 + lvl*85, 1, 10000)});
      if(lvl >= 4){
        const a2 = weightedPick(activePool, weightByRarity);
        if(a2) shop.stock.push({kind:"skill", id:a2.id, price: clamp(260 + lvl*95, 1, 10000)});
      }
    }
    if(PASSIVES && PASSIVES.length && lvl >= 3){
      const p1 = weightedPick(PASSIVES, weightByRarity);
      if(p1) shop.stock.push({kind:"passive", id:p1.id, price: clamp(320 + lvl*95, 1, 10000)});
      if(lvl >= 8){
        const p2 = weightedPick(PASSIVES, weightByRarity);
        if(p2) shop.stock.push({kind:"passive", id:p2.id, price: clamp(380 + lvl*110, 1, 10000)});
      }
    }

const skLines = [
      "‚ÄúMu·ªën g√¨ c≈©ng c√≥‚Ä¶ mi·ªÖn l√† c√≥ ti·ªÅn.‚Äù",
      "‚ÄúC√≥ tip th√¨ t√¥i m·ªõi m·ªü kho sau.‚Äù",
      "‚ÄúT√¥i b·∫Øt ƒë·∫ßu tin b·∫°n l√† kh√°ch s·ªôp.‚Äù",
      "‚ÄúH√†ng hi·∫øm‚Ä¶ ch·ªâ b√°n cho ng∆∞·ªùi bi·∫øt ƒëi·ªÅu.‚Äù",
      "‚Äúƒê·ª´ng h·ªèi ngu·ªìn. Mua ƒëi.‚Äù",
    ];
    $shopkeeperLine.textContent = skLines[Math.min(skLines.length-1, shop.level)];
  }

  function openShop(){ refreshShopStock(false); renderShop(); showOverlay("overlayShop"); }
  function renderShop(){
    const shop = game.world.shop;
    $shopLevelTag.textContent = `Shop level: ${shop.level}`;
    $shopTipCostTag.textContent = `Tip cost: ${shopTipCost(shop.level)} v√†ng`;
    $shopList.innerHTML = "";
    for(const entry of shop.stock){
      let name="", desc="", rar="common";
      if(entry.kind==="stack" || entry.kind==="gear"){
        const meta = itemMeta(entry.id); if(!meta) continue;
        name = meta.name; desc = meta.desc||"‚Äî"; rar = meta.rarity||"common";
      } else if(entry.kind==="skill"){
        const s = skillById(entry.id); if(!s) continue;
        name = `K·ªπ nƒÉng: ${s.name}`; desc = s.desc; rar = s.rarity || "common";
      } else if(entry.kind==="passive"){
        const ps = passiveById(entry.id); if(!ps) continue;
        name = `B·ªã ƒë·ªông: ${ps.name}`; desc = ps.desc; rar = ps.rarity || "common";
      }
      const div = document.createElement("div");
      div.className = "listItem";
      div.innerHTML = `
        <div class="left">
          <div class="name">${name} <span class="rar ${rar}">${rarityLabel(rar)}</span></div>
          <div class="desc">${desc}</div>
        </div>
        <div style="text-align:right;">
          <div style="font-weight:900;">${entry.price} v√†ng</div>
          <button class="btn btnPrimary" style="margin-top:8px;">Mua</button>
        </div>
      `;
      div.querySelector("button").addEventListener("click", ()=> buyFromShop(entry));
      $shopList.appendChild(div);
    }
  }
  function learnSkill(skillId){
    if(!skillById(skillId)) return;
    if(game.player.learnedSkills.includes(skillId)) return;
    game.player.learnedSkills.push(skillId);
    for(let i=0;i<4;i++){ if(!game.player.skillSlots[i]){ game.player.skillSlots[i]=skillId; break; } }
  }
  function learnPassive(pid){
    if(!passiveById(pid)) return;
    if(game.player.passives.includes(pid)) return;
    game.player.passives.push(pid);
  }
  function buyFromShop(entry){
    if(!preAction(1, "mua h√†ng")) return;
    if(game.player.gold < entry.price) return;
    game.player.gold -= entry.price;
    // 40% shop l·ª´a ƒë·∫£o (ch·ªâ √°p d·ª•ng cho v·∫≠t ph·∫©m/trang b·ªã)
    const SCAM_SHOP = 0.40;
    if((entry.kind==="stack" || entry.kind==="gear") && Math.random() < SCAM_SHOP){
      addLog("‚ö†Ô∏è Shop l·ª´a ƒë·∫£o! B·∫°n m·∫•t ti·ªÅn nh∆∞ng kh√¥ng nh·∫≠n ƒë∆∞·ª£c h√†ng.");
      pushStory("‚ö†Ô∏è B·∫°n b·ªã shop l·ª´a: tr·∫£ ti·ªÅn nh∆∞ng kh√¥ng nh·∫≠n ƒë∆∞·ª£c m√≥n g√¨.");
      countAction();
      renderAll();
      renderShop();
      return;
    }

    if(entry.kind==="stack"){
      addStack(entry.id, 1);
      addLog(`Mua <b>${itemMeta(entry.id).name}</b> (-${entry.price} v√†ng).`);
      pushStory(`B·∫°n mua ${itemMeta(entry.id).name}.`);
    } else if(entry.kind==="gear"){
      addGear(entry.id, 0);
      addLog(`Mua <b>${itemMeta(entry.id).name}</b> (-${entry.price} v√†ng).`);
      pushStory(`B·∫°n mua ${itemMeta(entry.id).name} (gear).`);
    } else if(entry.kind==="skill"){
      learnSkill(entry.id);
      addLog(`Mua <b>k·ªπ nƒÉng</b>: ${skillById(entry.id)?.name||entry.id}.`);
      pushStory(`B·∫°n h·ªçc k·ªπ nƒÉng: ${skillById(entry.id)?.name||entry.id}.`);
    } else if(entry.kind==="passive"){
      learnPassive(entry.id);
      addLog(`Mua <b>b·ªã ƒë·ªông</b>: ${passiveById(entry.id)?.name||entry.id}.`);
      pushStory(`B·∫°n nh·∫≠n b·ªã ƒë·ªông: ${passiveById(entry.id)?.name||entry.id}.`);
    }
    countAction();
    computeStats(false);
    renderAll();
    renderShop();
  }
  function tipShop(){
    if(!preAction(1, "tip ch·ªß qu√°n")) return;
    const shop = game.world.shop;
    const cost = shopTipCost(shop.level);
    if(game.player.gold < cost) return;
    game.player.gold -= cost;
    shop.level = shop.level + 1;
    addLog(`Tip shop <b>-${cost} v√†ng</b>. Shop l√™n level <b>${shop.level}</b>.`);
    refreshShopStock(true);
    renderShop();
    countAction();
    renderAll();
  }

  let gachaBusy = false;
  function gachaRollOnce(){
    const tier = rollGachaTier();
    const pool = GACHA_TIERS[tier] || GACHA_TIERS.trash;
    const id = pick(pool);
    const meta = itemMeta(id);
    if(meta.type === "weapon" || meta.type === "armor") addGear(id, 0);
    else addStack(id, 1);
    return {id, meta, tier};
  }
  function openGachaMulti(count){
    if(!preAction(1, "quay gacha")) return;
    if(gachaBusy) return;
    const unit = 100;
    const cost = (count===10) ? unit*15 : unit;
    if(game.player.gold < cost) return;
    game.player.gold -= cost;
    countAction();
    renderAll();
    gachaBusy = true;
    $overlayGacha.style.display = "flex";
    $gachaReveal.style.display = "none";
    $btnGachaOk.style.display = "none";
    $gachaStatus.textContent = (count===10) ? "ƒêang m·ªü 10 h√≤m‚Ä¶" : "ƒêang m·ªü h√≤m‚Ä¶";
    setTimeout(()=>{
      const got=[];
      for(let i=0;i<count;i++) got.push(gachaRollOnce());
      const tally={trash:0, common:0, rare:0, legend:0, legendary:0};
      for(const g of got){ const rr = (g.meta.rarity||"common"); tally[rr] = (tally[rr]||0)+1; }
      const top = got.slice().sort((a,b)=>rarityRank(b.meta.rarity)-rarityRank(a.meta.rarity))[0];
      $gachaStatus.textContent = "K·∫øt qu·∫£:";
      $gachaReveal.style.display = "block";
      const lines = got.map(g=>`<div class=\"mini\">‚Ä¢ ${g.meta.name} <span class=\"rar ${g.meta.rarity}\">${rarityLabel(g.meta.rarity)}</span></div>`).join("");
      $gachaReveal.innerHTML = `
        <div class=\"big\">${(count===10)?"Gacha x10":"Gacha x1"} ‚Äî Best: ${top.meta.name} <span class=\"rar ${top.meta.rarity}\">${rarityLabel(top.meta.rarity)}</span></div>
        <div class=\"small\">Legendary:${tally.legendary||0} ‚Ä¢ Legend:${tally.legend||0} ‚Ä¢ Rare:${tally.rare||0} ‚Ä¢ Common:${tally.common||0} ‚Ä¢ Trash:${tally.trash||0}</div>
        <div style=\"margin-top:8px; max-height:220px; overflow:auto;\">${lines}</div>
      `;
      addLog(`Gacha x${count}: nh·∫≠n ${count} m√≥n. Best: <b>${top.meta.name}</b>.`);
      pushStory(`B·∫°n quay gacha x${count} (-${cost} v√†ng). Best: <b>${top.meta.name}</b>.`);
      onQuestEvent('gacha', count);
      $btnGachaOk.style.display = "inline-flex";
      gachaBusy = false;
      computeStats(false);
      renderAll();
    }, 900);
  }

  function openGacha(){
    // m·ªü UI gacha, CH∆ØA quay
    showOverlay("overlayGacha");
    $gachaReveal.style.display = "block";
    $btnGachaOk.style.display = "none";
    $gachaStatus.textContent = "Ch·ªçn gacha x1 ho·∫∑c x10.";
    $gachaReveal.innerHTML = `
      <div class="big">Gacha</div>
      <div class="small">Gi√°: x1 = 100 v√†ng ‚Ä¢ x10 = 1500 v√†ng</div>
      <div class="mini">Tip: Luck Elixir gi√∫p t·ªâ l·ªá ra ƒë·ªì x·ªãn cao h∆°n.</div>
    `;
  }

  function openGachaAndRoll(){ return openGacha(); }

  function _deprecated_openGachaAndRoll_old(){
    if(!preAction(1, "quay gacha")) return;
    if(gachaBusy) return;
    const cost = 100;
    if(game.player.gold < cost) return;
    game.player.gold -= cost;
    countAction();
    renderAll();
    gachaBusy = true;
    $overlayGacha.style.display = "flex";
    $gachaReveal.style.display = "none";
    $btnGachaOk.style.display = "none";
    $gachaStatus.textContent = "ƒêang m·ªü h√≤m‚Ä¶";
    setTimeout(()=>{
      const tier = rollGachaTier();
      const pool = GACHA_TIERS[tier] || GACHA_TIERS.trash;
      const id = pick(pool);
      const meta = itemMeta(id);
      if(meta.type === "weapon" || meta.type === "armor") addGear(id, 0);
      else addStack(id, 1);
      addLog(`Gacha ra <b>${meta.name}</b> (${rarityLabel(meta.rarity)}).`);
      pushStory(`B·∫°n quay gacha (-100 v√†ng)‚Ä¶ B·∫°n nh·∫≠n: ${meta.name} (${rarityLabel(meta.rarity)}).`);
      $gachaStatus.textContent = "K·∫øt qu·∫£:";
      $gachaReveal.style.display = "block";
      $gachaReveal.innerHTML = `<div class="big">${meta.name} <span class="rar ${meta.rarity}">${rarityLabel(meta.rarity)}</span></div><div class="small">${meta.desc || "‚Äî"}</div>`;
      $btnGachaOk.style.display = "inline-flex";
      gachaBusy = false;
      computeStats(false);
      renderAll();
    }, 1100);
  }

  let forgeSelectedUid = null;
  function openForge(){
    renderForgeList();
    $forgeDetail.textContent = "Ch·ªçn m·ªôt trang b·ªã.";
    $forgeHint.textContent = "";
    $btnForgeDo.disabled = true;
    forgeSelectedUid = null;
    showOverlay("overlayForge");
  }
  function renderForgeList(){
    const gears = getGears().filter(g=>{
      const m = itemMeta(g.id);
      return m && (m.type==="weapon" || m.type==="armor");
    });
    $forgeList.innerHTML = "";
    if(gears.length === 0){ $forgeList.innerHTML = `<div class="mini">B·∫°n kh√¥ng c√≥ v≈© kh√≠/gi√°p.</div>`; return; }
    for(const g of gears){
      const m = itemMeta(g.id);
      const enh = g.enh || 0;
      const equipped = (game.player.equipped.weaponUid===g.uid || game.player.equipped.armorUid===g.uid);
      const statLine = m.type==="weapon" ? `ATK ${m.atk||0} (+${enh})` : `DEF ${m.def||0} (+${enh})`;
      const div = document.createElement("div");
      div.className = "listItem";
      div.innerHTML = `
        <div class="left">
          <div class="name">${m.name} <span class="rar ${m.rarity}">${rarityLabel(m.rarity)}</span> ${equipped ? `<span class="rar common">Equipped</span>` : ""}</div>
          <div class="desc">${statLine}</div>
        </div>
        <div style="text-align:right;"><button class="btn btnPrimary">Ch·ªçn</button></div>
      `;
      div.querySelector("button").addEventListener("click", ()=>{ forgeSelectedUid = g.uid; renderForgeDetail(); });
      $forgeList.appendChild(div);
    }
  }
  function forgeCost(targetLevel){ return {gold: 20*targetLevel*targetLevel, ore: targetLevel}; }
  function forgeChanceText(n){ return n<=6 ? `1 / ${Math.pow(10,n).toLocaleString()}` : `1 / 10^${n}`; }
  function renderForgeDetail(){
    if(!forgeSelectedUid){ $btnForgeDo.disabled = true; return; }
    const g = findGearByUid(forgeSelectedUid); if(!g){ $btnForgeDo.disabled = true; return; }
    const m = itemMeta(g.id);
    const cur = g.enh || 0;
    const target = cur + 1;
    const cost = forgeCost(target);
    $forgeDetail.innerHTML = `
      <div><b>${m.name}</b> hi·ªán t·∫°i: <b>+${cur}</b></div>
      <div style="margin-top:6px;">N√¢ng l√™n: <b>+${target}</b></div>
      <div style="margin-top:10px; color: rgba(255,255,255,.62); font-size:12px; line-height:1.55;">
        Cost: <b>${cost.gold}</b> v√†ng + <b>${cost.ore}</b> Qu·∫∑ng<br>
        Chance: <b>${forgeChanceText(target)}</b>
      </div>`;
    const can = (game.player.gold >= cost.gold) && (stackQty("ore") >= cost.ore) && (target <= 100);
    $btnForgeDo.disabled = !can;
    $forgeHint.textContent = can ? "Nh·∫•n 'N√¢ng c·∫•p' ƒë·ªÉ th·ª≠." : "Kh√¥ng ƒë·ªß v√†ng/qu·∫∑ng ho·∫∑c ƒë√£ +100.";
    $btnForgeDo.onclick = ()=> attemptForge(g.uid, target, cost.gold, cost.ore);
  }
  function attemptForge(gearUid, target, goldCost, oreCost){
    if(!preAction(2, "r√®n ƒë·ªì")) return;
    const g = findGearByUid(gearUid);
    if(!g || target>100) return;
    if(game.player.gold < goldCost || stackQty("ore") < oreCost) return;
    game.player.gold -= goldCost;
    removeStack("ore", oreCost);
    let ok = succeedTenPow(target);
    // Luck Elixir: th√™m 1 l·∫ßn th·ª≠ n·ªØa (tƒÉng t·ªâ l·ªá th√†nh c√¥ng)
    if(!ok && hasLuckBuff()) ok = succeedTenPow(target);
    if(ok){ g.enh = target; addLog(`R√®n th√†nh c√¥ng: <b>${itemMeta(g.id).name} +${target}</b>.`); pushStory(`R√àN TH√ÄNH C√îNG! ${itemMeta(g.id).name} l√™n +${target}.`); }
    else {
      // th·∫•t b·∫°i: x√≥a item
      const idx = game.player.inv.findIndex(x=>x.uid===g.uid);
      if(idx>=0) game.player.inv.splice(idx,1);
      if(game.player.equipped.weaponUid===g.uid) game.player.equipped.weaponUid = null;
      if(game.player.equipped.armorUid===g.uid) game.player.equipped.armorUid = null;
      addLog(`R√®n th·∫•t b·∫°i: <b>${itemMeta(g.id).name}</b> ƒë√£ v·ª° v√† bi·∫øn m·∫•t!`);
      pushStory(`R√®n th·∫•t b·∫°i‚Ä¶ <b>${itemMeta(g.id).name}</b> b·ªã ph√° h·ªßy!`);
    }
    countAction(); computeStats(false); renderAll(); renderForgeList(); renderForgeDetail();
  }

  function fillTrialSelect(){ $trialSelect.innerHTML = GODS.map(g=>`<option value="${g.id}">${g.name} ‚Äî ${g.desc}</option>`).join(""); }
  function openTrial(){
    fillTrialSelect();
    if(!game.trialUI) game.trialUI = {mode:"god"};
    $trialSelect.value = game.trial.godId;
    if($trialModeSelect) $trialModeSelect.value = game.trialUI.mode || "god";
    renderTrialPanel();
    showOverlay("overlayTrial");
  }
  function renderTrialPanel(){
    const mode = ($trialModeSelect && $trialModeSelect.value) ? $trialModeSelect.value : "god";
    if(!game.trialUI) game.trialUI = {mode:"god"};
    game.trialUI.mode = mode;
    if($trialGodBlock) $trialGodBlock.style.display = (mode==="god") ? "block" : "none";
    if($trialHeroBlock) $trialHeroBlock.style.display = (mode==="hero") ? "block" : "none";
    if(mode==="hero") renderHeroTrial(); else renderTrial();
  }
  function renderTrial(){
    const g = godById($trialSelect.value);
    const best = game.trial.progress[g.id] || 0;
    $trialTags.innerHTML = `<span class="tag">B·∫°n ƒë√£ v∆∞·ª£t: ${best}/50</span><span class="tag">Nh·∫≠n ph∆∞·ªõc m·ªói 10 t·∫ßng</span>`;
    $trialProgress.textContent = `Ti·∫øn tr√¨nh ${g.name}: ${best}/50.`;
  }

  // ===== Hero Trial (Trial Anh H√πng) =====
  function renderHeroTrial(){
    const best = game.heroTrial?.best || 0;
    $heroTrialTags.innerHTML = `<span class="tag">B·∫°n ƒë√£ v∆∞·ª£t: ${best}/100</span><span class="tag">Qu√°i Lv99</span><span class="tag">Th∆∞·ªüng: Ph∆∞·ªõc L√†nh Anh H√πng + Th√°nh Ki·∫øm/Th√°nh Gi√°p</span>`;
    $heroTrialProgress.textContent = `Ti·∫øn tr√¨nh Trial Anh H√πng: ${best}/100.`;
  }
  function makeHeroTrialEnemy(floor){
    const pLv = game.player.level;
    // Boss t·∫ßng 100: b·∫£n sao anh h√πng Lv888
    if(floor >= 100){
      return {
        name:`B·∫£n Sao Anh H√πng (Lv888)`,
        tier:"trialHero",
        level:888,
        hp: 88888,
        atk: 1888,
        def: 1333,
        spd: 188,
        lootGold:[2000,4500],
        xp: 88888,
        enraged:false,
        justEnraged:false,
        debuffImmune:true,          // mi·ªÖn hi·ªáu ·ª©ng x·∫•u
        thanBan:false,
        thanBanTriggered:true,       // boss kh√¥ng k√≠ch ho·∫°t th·∫ßn ban theo ki·ªÉu "HP=0" (ƒë√£ l√† boss)
        noHealOpponent:true,         // ngƒÉn ƒë·ªëi th·ªß h·ªìi m√°u
        immortalThreshold:100,       // d∆∞·ªõi 100 HP -> b·∫•t t·ª≠ 2 l∆∞·ª£t
        immortalTriggerUsed:false,
        immortalTurns:0,
        equipmentNote:"Th√°nh Ki·∫øm r√®n +99 ‚Ä¢ Th√°nh Gi√°p r√®n +99",
      };
    }
    // Qu√°i th∆∞·ªùng: mi·ªÖn debuff, khi ch·∫øt s·∫Ω k√≠ch ho·∫°t Th·∫ßn Ban
    const scale = 1 + floor*0.08;
    return {
      name:`K·∫ª Canh T·∫ßng ${floor}`,
      tier:"trialHero",
      level:99,
      hp: Math.floor(2800*scale),
      atk: Math.floor(140*scale),
      def: Math.floor(95*scale),
      spd: Math.floor(45*scale),
      lootGold:[250,520],
      xp: Math.floor(900*scale),
      enraged:false,
      justEnraged:false,
      debuffImmune:true,
      thanBan:false,
      thanBanTriggered:false,
      immortalTurns:0,
    };
  }
  function startHeroTrial(){
    normalizeMode();
    if(!preAction(2, "trial anh h√πng")) return;
    if(game.world.heroNpc){
      pushStory(`‚ö†Ô∏è Trial Anh H√πng ƒë√£ b·ªã <b>kh√≥a</b> v√¨ NPC <b>${game.world.heroNpc.name}</b> ƒë√£ nh·∫≠n <b>Ph∆∞·ªõc L√†nh Anh H√πng</b>.`);
      addLog(`Trial Anh H√πng b·ªã kh√≥a (NPC ${game.world.heroNpc.name} ƒë√£ nh·∫≠n ph∆∞·ªõc).`);
      game.mode = {kind:"free", hint:"T·ª± do phi√™u l∆∞u."};
      return;
    }
    if(!game.heroTrial) game.heroTrial = {floor:1, best:0};
    game.mode = {kind:"heroTrial"};
    pushStory(`=== TRIAL ANH H√ôNG ===\nB·∫°n b∆∞·ªõc v√†o th·ª≠ th√°ch 100 t·∫ßng. M·ªói t·∫ßng qu√°i Lv99.`);
    addLog("<b>Trial Anh H√πng</b> b·∫Øt ƒë·∫ßu.");
    countAction();
    startBattle(makeHeroTrialEnemy(game.heroTrial.floor), {kind:"heroTrial"});
  }


  function makeTrialEnemy(floor){
    const pLv = game.player.level;
    // Qu√°i Trial Th·∫ßn lu√¥n cao h∆°n player 1 c·∫•p
    const lv = Math.max(1, pLv + 1);
    const scale = 1 + floor*0.18 + pLv*0.04;

    // Boss t·∫ßng 50: b·∫£n sao th·∫ßn Lv444, b·∫•t t·ª≠ 1 l∆∞·ª£t m·ªói 6 l∆∞·ª£t
    if(floor >= 50){
      return {
        name:`B·∫£n Sao Th·∫ßn (Lv444)`,
        tier:"trial",
        level:444,
        hp: Math.round(5200*scale),
        atk: Math.round(420*scale),
        def: Math.round(260*scale),
        spd: Math.round(120*scale),
        lootGold:[0,0],
        xp: Math.round(24000*scale),
        enraged:false,
        justEnraged:false,
        immortalEvery:6,
        turnsTaken:0,
        immortalTurns:0,
      };
    }

    return {
      name:`Th·ª≠ Th√°ch T·∫ßng ${floor}`,
      tier:"trial",
      level:lv,
      hp:Math.round(54*scale + floor*5),
      atk:Math.round(14*scale + floor*1.2),
      def:Math.round(8*scale + floor*0.9),
      spd:Math.round(7*scale + floor*0.5),
      lootGold:[0,0],
      xp:Math.round(55 + floor*12),
      enraged:false,
      justEnraged:false,
      immortalTurns:0,
    };
  }
  function startOrResumeTrial(godId){
    if(!preAction(4, "trial")) return;
    if(game.battle.active) return;
    if(game.mode.kind !== "free") return;
    game.trial.godId = godId;
    const best = game.trial.progress[godId] || 0;
    const nextFloor = best + 1;
    if(nextFloor > 50) return;
    game.trial.active = true;
    game.trial.floor = nextFloor;
    game.mode = {kind:"trial", hint:`Trial ${godById(godId).name} t·∫ßng ${game.trial.floor}/50`};
    pushStory(`B·∫°n b∆∞·ªõc v√†o Trial c·ªßa ${godById(godId).name}. T·∫ßng ${game.trial.floor}/50.`);
    addLog(`B·∫Øt ƒë·∫ßu Trial: ${godById(godId).name} t·∫ßng ${game.trial.floor}.`);
    countAction();
    startBattle(makeTrialEnemy(game.trial.floor), {kind:"trial", godId, floor: game.trial.floor});
  }

  function envoyEnemy(){
    const pLv = game.player.level;
    const lv = 70 + pLv + 30;
    const scale = 1 + pLv*0.03;
    return { name:"S·ª© Gi·∫£ c·ªßa Ch√∫a", tier:"envoy", level:lv, hp:Math.round(520*scale), atk:Math.round(54*scale), def:Math.round(34*scale), spd:Math.round(16*scale), lootGold:[180,320], xp:Math.round(360 + pLv*35), enraged:false, justEnraged:false, dropBlessing:true };
  }
  function spawnEnemy(kind="normal", floor=1){
    if(kind === "dungeon" && Math.random() < 0.20) return envoyEnemy();
    const baseMonsters = [
      {name:"Slime", baseLv:1, hp:32, atk:8, def:2, spd:3, lootGold:[18,28], xp: 28},
      {name:"S√≥i R·ª´ng", baseLv:2, hp:48, atk:12, def:3, spd:6, lootGold:[22,34], xp: 36},
      {name:"B√≥ng ƒê√™m", baseLv:3, hp:44, atk:14, def:2, spd:7, lootGold:[24,38], xp: 40},
      {name:"Gi√°p S·∫Øt", baseLv:3, hp:68, atk:11, def:9, spd:3, lootGold:[28,44], xp: 44},
      {name:"ƒê·∫°o T·∫∑c", baseLv:4, hp:56, atk:16, def:4, spd:7, lootGold:[30,48], xp: 48},
    ];
    const b = pick(baseMonsters);
    const pLv = game.player.level;
    const baseLv = Math.max(1, b.baseLv + Math.floor(pLv*0.95) + (kind==="dungeon" ? floor : 0));
    const scale = 1 + pLv*0.12 + (kind==="dungeon" ? floor*0.26 : 0.0) + 0.10;
    return { name:b.name, tier:kind, level:baseLv, hp:Math.round(b.hp*scale), atk:Math.round(b.atk*scale), def:Math.round(b.def*scale), spd:Math.round(b.spd*scale), lootGold:b.lootGold, xp:Math.round(b.xp * (1 + pLv*0.10) + (kind==="dungeon" ? floor*16 : 0)), enraged:false, justEnraged:false };
  }

  function startDungeon(){
    normalizeMode();
    if(!preAction(4, "v√†o dungeon")) return;
    if(game.battle.active) return;
    if(game.mode.kind !== "free") return;    const names = ["Ph√°o ƒê√†i ƒê·∫°o T·∫∑c", "H·∫ßm N√¥ D·ªãch", "Di T√≠ch Tempest", "Nh√† M√°y Rider", "CƒÉn C·ª© Sentai", "T√†n T√≠ch Grimoire"];
    game.dungeon.active = true;
    game.dungeon.name = pick(names);
    game.dungeon.floor = 1;
    game.dungeon.maxFloor = randInt(4, 7);
    game.mode = {kind:"dungeon", hint:`Dungeon ${game.dungeon.name} (${game.dungeon.floor}/${game.dungeon.maxFloor})`};
    pushStory(`B·∫°n b∆∞·ªõc v√†o <b>${game.dungeon.name}</b>. Dungeon c√≥ ${game.dungeon.maxFloor} t·∫ßng.`);
    addLog(`V√†o dungeon <b>${game.dungeon.name}</b>.`);
    countAction();
    startBattle(spawnEnemy("dungeon", game.dungeon.floor), {kind:"dungeon", floor: game.dungeon.floor});
  }

  function specialEncounterEnemy(){
    const roll = Math.random();
    const pLv = game.player.level;
    const lv = pLv + 999; // lu√¥n cao h∆°n player theo m·ªëc 999
    const s = 1 + (pLv * 0.002);

    if(roll < 0.050){
      return {
        name:`Anh H√πng (Lv${lv})`,
        tier:"boss999",
        level:lv,
        hp: Math.floor(140000 * s),
        atk: Math.floor(2800 * s),
        def: Math.floor(1800 * s),
        spd: Math.floor(120 * (1 + pLv*0.001)),
        lootGold:[9000, 16000],
        xp: Math.floor(160000 * s),
        enraged:false,
        justEnraged:false,
        dropBossRewards:true,
        passiveHighLevel:true,
        passiveDestruction:true, // h·ªßy di·ªát: m·ªói l∆∞·ª£t l·∫•y 1 th·ª© c·ªßa player
      };
    }
    if(roll < 0.100){
      return {
        name:`Ma V∆∞∆°ng (Lv${lv})`,
        tier:"boss999",
        level:lv,
        hp: Math.floor(230000 * s),
        atk: Math.floor(3600 * s),
        def: Math.floor(2100 * s),
        spd: Math.floor(110 * (1 + pLv*0.001)),
        lootGold:[12000, 22000],
        xp: Math.floor(220000 * s),
        enraged:false,
        justEnraged:false,
        dropBossRewards:true,
        passiveHighLevel:true,
        passiveDestruction:true,
      };
    }
    return null;
  }

  function openSkills(){ renderSkillManager(); showOverlay("overlaySkills"); }
  function renderSkillManager(){
    const learned = game.player.learnedSkills.map(id=>skillById(id)).filter(Boolean);
    for(let i=0;i<4;i++){ if(game.player.skillSlots[i] && !game.player.learnedSkills.includes(game.player.skillSlots[i])) game.player.skillSlots[i]=null; }
    const optsHtml = (selectedId)=>{
      const list = learned.slice().sort((a,b)=>{
        const ra = RARITY.indexOf(a.rarity||"common");
        const rb = RARITY.indexOf(b.rarity||"common");
        return rb-ra || a.name.localeCompare(b.name);
      });
      const options = [`<option value="">(tr·ªëng)</option>`].concat(list.map(s=>{
        const sel = (s.id===selectedId) ? "selected" : "";
        return `<option ${sel} value="${s.id}">${s.name} ‚Ä¢ ${rarityLabel(s.rarity)} ‚Ä¢ MP ${s.mp||0}</option>`;
      }));
      return options.join("");
    };
    $skillSlotsWrap.innerHTML = "";
    for(let i=0;i<4;i++){
      const row = document.createElement("div");
      row.className = "listItem";
      row.innerHTML = `
        <div class="left">
          <div class="name">√î skill ${i+1}</div>
          <div class="desc">Ch·ªçn 1 k·ªπ nƒÉng cho slot.</div>
        </div>
        <div style="min-width: 220px;">
          <select style="width:100%; padding:10px 12px; border-radius: 12px; border:1px solid rgba(255,255,255,.14); background: rgba(0,0,0,.22); color: rgba(255,255,255,.92);" data-slot="${i}">
            ${optsHtml(game.player.skillSlots[i])}
          </select>
        </div>`;
      row.querySelector("select").addEventListener("change", (e)=>{
        const slot = parseInt(e.target.getAttribute("data-slot"),10);
        const val = e.target.value || null;
        game.player.skillSlots[slot] = val;
        if(val){
          for(let j=0;j<4;j++) if(j!==slot && game.player.skillSlots[j]===val) game.player.skillSlots[j]=null;
          renderSkillManager();
        }
        renderAll();
      });
      $skillSlotsWrap.appendChild(row);
    }
    const lines = learned.slice().sort((a,b)=>{
      const ra = RARITY.indexOf(a.rarity||"common");
      const rb = RARITY.indexOf(b.rarity||"common");
      return rb-ra || a.name.localeCompare(b.name);
    }).map(s=>{
      const isInSlot = game.player.skillSlots.includes(s.id);
      return `<div class="listItem"><div class="left"><div class="name">${s.name} <span class="rar ${s.rarity}">${rarityLabel(s.rarity)}</span> ${isInSlot?`<span class="rar common">In slot</span>`:""}</div><div class="desc">${s.desc} ‚Ä¢ MP ${s.mp||0} ‚Ä¢ CD ${s.cd||0} ‚Ä¢ Scale ${s.scale||"-"}</div></div></div>`;
    }).join("");
    $skillListWrap.innerHTML = lines || `<div class="mini">B·∫°n ch∆∞a c√≥ skill n√†o.</div>`;
  }

  function dmgFormula(att, def, pierce=0.0, pure=false){
    if(pure) return Math.max(1, Math.round(att + randInt(-2,3)));
    const effDef = Math.max(0, Math.round(def * (1 - pierce)));
    const raw = att - Math.floor(effDef * 0.70);
    return Math.max(1, raw + randInt(-2, 3));
  }
  function applyRegenEndTurn(){
    const p = game.player;
    const hpRegenPct = p._derived?.hpRegen || 0;
    const mpRegenPct = p._derived?.mpRegen || 0;
    if(hpRegenPct > 0){
      const heal = Math.max(1, Math.floor(p.max.HP * hpRegenPct));
      const e = game.battle.enemy;
      if(e && e.noHealOpponent){
        game.battle.log.push(`<b>${e.name}</b> kh√≥a h·ªìi m√°u! B·ªã ƒë·ªông h·ªìi HP b·ªã v√¥ hi·ªáu.`);
      }else{
        p.stats.HP = clamp(p.stats.HP + heal, 0, p.max.HP);
        game.battle.log.push(`B·ªã ƒë·ªông h·ªìi <b>+${heal} HP</b>.`);
      }
    }
    if(mpRegenPct > 0){
      const gain = Math.max(1, Math.floor(p.max.MP * mpRegenPct));
      p.stats.MP = clamp(p.stats.MP + gain, 0, p.max.MP);
      game.battle.log.push(`B·ªã ƒë·ªông h·ªìi <b>+${gain} MP</b>.`);
    }
  }
  function tickEnemyDots(){
    const es = game.battle.enemyStatuses;
    if(es.poison && es.poison.turns > 0){
      const dmg = Math.max(1, Math.floor(game.battle.enemyMaxHP * es.poison.pct));
      game.battle.enemyHP = Math.max(0, game.battle.enemyHP - dmg);
      game.battle.log.push(`ƒê·ªôc g√¢y <b>${dmg}</b> s√°t th∆∞∆°ng.`);
      es.poison.turns -= 1;
      if(es.poison.turns <= 0) delete es.poison;
    }
  }
  function decBuffs(){
    const ps = game.battle.statuses;
    const es = game.battle.enemyStatuses;
    for(const key of Object.keys(ps)){
      if(ps[key]?.turns!=null){ ps[key].turns -= 1; if(ps[key].turns <= 0) delete ps[key]; }
    }
    for(const key of Object.keys(es)){
      if(es[key]?.turns!=null){ es[key].turns -= 1; if(es[key].turns <= 0) delete es[key]; }
    }
  }

  function startBattle(enemy, context){
    computeStats(false);
    if(enemy && (enemy.level>=999 || /Ma V∆∞∆°ng|Anh H√πng/.test(enemy.name))){
      showCinematic("BATTLE", `${enemy.name} ‚Ä¢ Lv ${enemy.level}`);
    }
    game.battle.active = true;
    game.battle.enemy = enemy;
    game.battle.enemyHP = enemy.hp;
    game.battle.enemyMaxHP = enemy.hp;
    game.battle.turn = "player";
    game.battle.guard = false;
    game.battle.shieldHP = 0;
    const startShield = game.player._special?.gearStartShield || 0;
    if(startShield > 0){
      game.battle.shieldHP = Math.floor(game.player.max.HP * startShield);
      if(game.battle.shieldHP>0) addBattleLog(`üõ°Ô∏è Khi√™n kh·ªüi ƒë·∫ßu: +${game.battle.shieldHP}`);
    }
    game.battle.statuses = {};
    game.battle.enemyStatuses = {};
    game.battle.cds = {};
    game.battle.log = [`B·∫°n ch·∫°m tr√°n <b>${enemy.name}</b> (Lv ${enemy.level}).`];
    game.battle.heroWillUsed = false;
    game.battle.context = context || {kind:"normal"};

    const pSpd = game.player.stats.DEX + (game.player._derived?.spd || 0) + randInt(1,6);
    const eSpd = enemy.spd + randInt(1,6);
    game.battle.turn = (pSpd >= eSpd) ? "player" : "enemy";

    addLog(`Battle: <b>${enemy.name}</b> (Lv ${enemy.level}).`);
    renderAll();
    if(game.battle.turn === "enemy") setTimeout(()=>enemyTurn(), 420);
  }

  function awardBossRewards(){
    const alreadyGear = getGears().some(g=>g.id==="ma_cuong_robe");
    if(!alreadyGear) addGear("ma_cuong_robe", 0);
    if(!hasArtifact("hero_will")) addStack("hero_will", 1);
    pushStory("=== BOSS REWARD ===\nB·∫°n nh·∫≠n ƒë∆∞·ª£c: √Åo Ch·ªâ Ma C∆∞∆°ng + √ù Ch√≠ Anh H√πng!");
    addLog("<b>Boss reward</b>: √Åo Ch·ªâ Ma C∆∞∆°ng + √ù Ch√≠ Anh H√πng.");
  }

  function endBattle(victory){
    const ctx = game.battle.context || {kind:"normal"};
    const enemy = game.battle.enemy;
    game.battle.active = false;
    game.battle.enemy = null;
    game.battle.context = null;
    $battleUI.style.display = "none";

    if(victory){
      grantExp(Math.floor((enemy.xp || Math.max(10, enemy.level * 10)) * 1.6 * (game._forcedRewardMult||1)));
      // Tensura-like: t√≠ch Souls + Predator growth
      ensureTensuraState();
      const soulGain = (enemy.tier==="boss") ? 5 : 1;
      game.player.souls += soulGain;
      if(soulGain>0) addLog(`+${soulGain} Souls (t·ªïng: ${game.player.souls}).`);


      game.world.lastDefeated = {name: enemy.name, level: enemy.level, tier: enemy.tier||"normal"};
      if(hasSkill("ts_predator")){
        game.player.predatorStacks += 1;
        // m·ªói 3 l·∫ßn h·∫•p th·ª•: +1 ch·ªâ s·ªë ng·∫´u nhi√™n (tƒÉng vƒ©nh vi·ªÖn base)
        if(game.player.predatorStacks % 3 === 0){
          const keys = ["STR","DEX","INT","DEF","CHA","LUK"];
          const k = pick(keys);
          game.player.base[k] = (game.player.base[k]||0) + 1;
          addLog(`üß™ Predator h·∫•p th·ª•: <b>${k}+1</b> (vƒ©nh vi·ªÖn).`);
        }else{
          addLog("üß™ Predator h·∫•p th·ª•: ti·∫øn h√≥a ch·∫≠m r√£i‚Ä¶");
        }
        // c∆° h·ªôi nh·ªè nh·∫≠n passive hi·∫øm (ƒë·∫°i kh√°i ‚Äúph√¢n t√≠ch‚Äù)
        if(Math.random() < 0.06){
          const pool = PASSIVES.filter(x=>["legend","legendary"].includes(x.rarity));
          const cand = pick(pool);
          if(cand && !game.player.passives.includes(cand.id)){
            game.player.passives.push(cand.id);
            addLog(`üìò Predator ph√¢n t√≠ch: nh·∫≠n passive <b>${cand.name}</b>.`);
          }
        }
      }
      if(enemy.lootGold && enemy.lootGold[1] > 0){
        const gold = Math.floor(randInt(enemy.lootGold[0], enemy.lootGold[1]) * 3.0);
        game.player.gold += gold;
        addLog(`Nh·∫∑t <b>+${gold} v√†ng</b>.`);
        onQuestEvent('earn', gold);
      }
      if(enemy.dropBossRewards) awardBossRewards();
      if(enemy.dropBlessing){
        const b = randomBlessing();
        game.player.blessings.push(b);
        pushStory(`S·ª© gi·∫£ r∆°i ph∆∞·ªõc: <b>${b.name}</b> (${b.desc}).`);
        addLog(`Drop ph∆∞·ªõc: <b>${b.name}</b>.`);
      }
      if(ctx.kind === "trial"){
        if(ctx.floor >= 20 && Math.random() < 0.18){
          addStack("luck_elixir", 1);
          pushStory("üçÄ B·∫°n nh·∫≠n <b>Luck Elixir</b> t·ª´ Trial! (d√πng ƒë·ªÉ tƒÉng luck 2 turn)");
          addLog("Nh·∫≠n <b>Luck Elixir</b> t·ª´ Trial.");
        }
        game.trial.progress[ctx.godId] = Math.max(game.trial.progress[ctx.godId] || 0, ctx.floor);
        if(ctx.floor % 10 === 0){
          const b = randomBlessing();
          game.player.blessings.push(b);
          pushStory(`B·∫°n v∆∞·ª£t Trial t·∫ßng ${ctx.floor}. Nh·∫≠n ph∆∞·ªõc: <b>${b.name}</b> (${b.desc}).`);
          addLog(`Trial ph∆∞·ªõc: <b>${b.name}</b>.`);
        } else {
          pushStory(`B·∫°n v∆∞·ª£t Trial t·∫ßng ${ctx.floor}. (Ph∆∞·ªõc nh·∫≠n ·ªü t·∫ßng 10/20/30/40/50)`);
        }
        if(ctx.floor >= 50){
          pushStory(`B·∫°n ƒë√£ ho√†n th√†nh 50 t·∫ßng Trial c·ªßa ${godById(ctx.godId).name}!`);
          addLog(`Ho√†n th√†nh Trial: ${godById(ctx.godId).name}.`);
          game.mode = {kind:"free", hint:"T·ª± do phi√™u l∆∞u."};
          game.trial.active = false;
          game.awaitingNext = null;
        } else {
          game.awaitingNext = {kind:"trial", godId: ctx.godId, nextFloor: ctx.floor + 1};
          game.mode = {kind:"trial", hint:`Trial ${godById(ctx.godId).name} ch·ªù next`};
        }
      } else if(ctx.kind === "heroTrial"){
        game.heroTrial.best = Math.max(game.heroTrial.best || 0, ctx.floor);
        if(ctx.floor >= 100){
          // th∆∞·ªüng l·ªõn
          if(!game.player.blessings.some(b=>b.id==="hero_blessing")){
            game.player.blessings.push(HERO_BLESSING);
          }
          // set hi·ªáu l·ª±c lv 999
          game.player.level = Math.max(game.player.level, 999);
          // trao ƒë·ªì
          addItem("holy_sword", 1);
          addItem("holy_armor", 1);
          pushStory("üèÜ B·∫°n chinh ph·ª•c <b>Trial Anh H√πng</b> 100 t·∫ßng! Nh·∫≠n <b>Ph∆∞·ªõc L√†nh Anh H√πng</b>, <b>Th√°nh Ki·∫øm</b> v√† <b>Th√°nh Gi√°p</b>.");
          addLog("<b>Trial Anh H√πng</b>: ho√†n th√†nh 100 t·∫ßng!");
          game.mode = {kind:"free", hint:"T·ª± do phi√™u l∆∞u."};
          game.awaitingNext = null;
        } else {
          game.awaitingNext = {kind:"heroTrial", nextFloor: ctx.floor + 1};
          game.mode = {kind:"heroTrial", hint:`Trial Anh H√πng ch·ªù next`};
          pushStory(`B·∫°n v∆∞·ª£t Trial Anh H√πng t·∫ßng ${ctx.floor}.`);
        }
      } else if(ctx.kind === "dungeon"){
        // Safety: n·∫øu ctx.floor b·ªã thi·∫øu/kh√°c th∆∞·ªùng th√¨ d√πng game.dungeon.floor hi·ªán t·∫°i
        const floor = (typeof ctx.floor === "number" && !Number.isNaN(ctx.floor)) ? ctx.floor : (game.dungeon.floor || 1);
        const maxF = (typeof game.dungeon.maxFloor === "number" && game.dungeon.maxFloor > 0) ? game.dungeon.maxFloor : floor;
        game.dungeon.floor = floor;
        game.dungeon.maxFloor = maxF;

        if(floor >= maxF){
          pushStory(`B·∫°n ho√†n th√†nh dungeon <b>${game.dungeon.name}</b>!`);
          addLog(`Ho√†n th√†nh dungeon <b>${game.dungeon.name}</b>.`);
          game.mode = {kind:"free", hint:"T·ª± do phi√™u l∆∞u."};
          game.dungeon.active = false;
          game.dungeon.floor = 0;
          game.dungeon.maxFloor = 0;
          game.dungeon.name = "";
          game.awaitingNext = null;
        } else {
          game.awaitingNext = {kind:"dungeon", nextFloor: floor + 1};
          game.mode = {kind:"dungeon", hint:`Dungeon ${game.dungeon.name} ch·ªù next`};
        }
      } else if(ctx.kind === "forced"){
        // forced events are stronger -> reward boost
        game._forcedRewardMult = 2.2;
        enemy._forcedMult = 1.6;
        game.mode = {kind:"free", hint:"T·ª± do phi√™u l∆∞u."};
      }
      computeStats(false);
      renderAll();
      return;
    }

    

    // N·∫øu thua Ma V∆∞∆°ng: m·∫•t to√†n b·ªô level & stat ƒë√£ c·ªông
    if(enemy && /Ma V∆∞∆°ng/i.test(enemy.name)){
      resetProgressAfterDemonKing();
      pushStory("üî• <b>Ma V∆∞∆°ng</b> nghi·ªÅn n√°t b·∫°n‚Ä¶ T·∫•t c·∫£ level v√† ch·ªâ s·ªë c·ªông theo level b·ªã x√≥a s·∫°ch!");
      addLog("üî• Thua Ma V∆∞∆°ng: reset level & base stats.");
    }

    const lost = Math.floor(game.player.gold * 0.10);
    game.player.gold = Math.max(0, game.player.gold - lost);

    // N·∫øu thua trong dungeon/trial th√¨ tho√°t ra ƒë·ªÉ tr√°nh "k·∫πt tr·∫°ng th√°i" kh√¥ng v√†o battle ƒë∆∞·ª£c
    if(ctx.kind === "dungeon"){
      game.dungeon.active = false;
      game.dungeon.floor = 0;
      game.dungeon.maxFloor = 0;
      game.dungeon.name = "";
      game.awaitingNext = null;
      game.mode = {kind:"free", hint:"T·ª± do phi√™u l∆∞u."};
    }
    if(ctx.kind === "trial"){
        if(ctx.floor >= 20 && Math.random() < 0.18){
          addStack("luck_elixir", 1);
          pushStory("üçÄ B·∫°n nh·∫≠n <b>Luck Elixir</b> t·ª´ Trial! (d√πng ƒë·ªÉ tƒÉng luck 2 turn)");
          addLog("Nh·∫≠n <b>Luck Elixir</b> t·ª´ Trial.");
        }
      game.trial.active = false;
      game.awaitingNext = null;
      game.mode = {kind:"free", hint:"T·ª± do phi√™u l∆∞u."};
    }

    if(ctx.kind === "heroTrial"){
      // Thua Trial Anh H√πng -> v·ªÅ free mode ngay
      game.awaitingNext = null;
      game.mode = {kind:"free", hint:"T·ª± do phi√™u l∆∞u."};
      pushStory("B·∫°n thua <b>Trial Anh H√πng</b> v√† b·ªã ƒë·∫©y ra ngo√†i. (V·ªÅ Free Mode)");
      addLog("Thua Trial Anh H√πng: v·ªÅ Free Mode.");
    }
    if(ctx.kind === "forced"){
      game.mode = {kind:"free", hint:"T·ª± do phi√™u l∆∞u."};
    }

    // H·ªìi l·∫°i m·ªôt ph·∫ßn ƒë·ªÉ ti·∫øp t·ª•c ch∆°i
    computeStats(false);
    game.player.stats.HP = Math.max(1, Math.floor(game.player.max.HP * 0.25));
    game.player.stats.MP = Math.max(0, Math.floor(game.player.max.MP * 0.25));
    computeStats(false);
    renderAll();
  }


  function tryEnrageInsteadOfDeath(){
    const enemy = game.battle.enemy;
    if(!enemy) return false;

    // H·ªá b·∫•t t·ª≠ theo l∆∞·ª£t (d√πng cho boss Trial & boss ƒë·∫∑c bi·ªát)
    if(enemy.immortalTurns && enemy.immortalTurns > 0){
      enemy.immortalTurns -= 1;
      game.battle.enemyHP = 1;
      game.battle.enemyMaxHP = Math.max(game.battle.enemyMaxHP, 1);
      game.battle.log.push(`<b>${enemy.name}</b> k√≠ch ho·∫°t <b>B·∫§T T·ª¨</b>! (c√≤n ${enemy.immortalTurns} l∆∞·ª£t)`);
      return true;
    }

    // Trial Anh H√πng: khi HP v·ªÅ 0 -> Th·∫ßn Ban (x10 ch·ªâ s·ªë, level = player + 199)
    if(enemy.tier === "trialHero" && !enemy.thanBanTriggered){
      enemy.thanBanTriggered = true;
      enemy.thanBan = true;
      const pLv = game.player.level;
      enemy.level = pLv + 199;
      enemy.name = "TH·∫¶N BAN " + enemy.name;

      enemy.atk = Math.max(1, Math.floor(enemy.atk * 10));
      enemy.def = Math.max(1, Math.floor(enemy.def * 10));
      enemy.spd = Math.max(1, Math.floor(enemy.spd * 10));
      enemy.hp  = Math.max(1, Math.floor(enemy.hp  * 10));

      game.battle.enemyMaxHP = enemy.hp;
      game.battle.enemyHP = enemy.hp;

      game.battle.log.push(`<b>${enemy.name}</b> kh√¥ng ch·∫øt‚Ä¶ n√≥ b∆∞·ªõc v√†o <b>TH·∫¶N BAN</b>! (x10 ch·ªâ s·ªë, Lv ${enemy.level})`);
      addLog("Trial Anh H√πng: qu√°i k√≠ch ho·∫°t <b>TH·∫¶N BAN</b>.");
      return true;
    }

    // Boss 999: lu√¥n c√≥ enrage
    if(enemy.tier === "boss999" && !enemy.enraged){
      enemy.enraged = true;
      enemy.justEnraged = true;
      enemy.name = "CU·ªíNG N·ªò " + enemy.name;
      enemy.atk = Math.max(1, enemy.atk * 10);
      enemy.def = Math.max(1, enemy.def * 10);
      enemy.spd = Math.max(1, enemy.spd * 10);
      enemy.hp = Math.max(1, enemy.hp * 10);
      game.battle.enemyMaxHP = enemy.hp;
      game.battle.enemyHP = enemy.hp;
      game.battle.log.push(`<b>${enemy.name}</b> g·∫ßm l√™n‚Ä¶ <b>CU·ªíNG N·ªò</b>! (Boss 999 lu√¥n k√≠ch ho·∫°t)`);
      addLog("Boss 999 k√≠ch ho·∫°t <b>CU·ªíNG N·ªò</b>.");
      return true;
    }

    if(enemy.enraged) return false;
    if(["boss","envoy"].includes(enemy.tier)) return false;
    if(Math.random() >= 0.10) return false;

    enemy.enraged = true;
    enemy.justEnraged = true;
    enemy.name = "CU·ªíNG N·ªò " + enemy.name;
    enemy.atk = Math.max(1, enemy.atk * 10);
    enemy.def = Math.max(1, enemy.def * 10);
    enemy.spd = Math.max(1, enemy.spd * 10);
    enemy.hp = Math.max(1, enemy.hp * 10);
    enemy.level = (Math.min(999, enemy.level + 30)) + 30;
    game.battle.enemyMaxHP = enemy.hp;
    game.battle.enemyHP = enemy.hp;
    game.battle.log.push(`<b>${enemy.name}</b> kh√¥ng ch·∫øt‚Ä¶ n√≥ v√†o tr·∫°ng th√°i <b>CU·ªíNG N·ªò</b>! HP h·ªìi ƒë·∫ßy + ch·ªâ s·ªë x10!`);
    addLog("Qu√°i v√†o tr·∫°ng th√°i <b>CU·ªíNG N·ªò</b> (x10).");
    return true;
  }

  function applyEnemyDefDown(def){
    const es = game.battle.enemyStatuses;
    if(es.defDown && es.defDown.turns>0) return Math.max(0, Math.round(def * (1 - es.defDown.pct)));
    return def;
  }

  function alliesAssistAttack(){
    ensureEmpire();
    const allies = (game.player.party||[]).filter(a=>a.hp>0);
    if(!allies.length || !game.battle.active) return;
    const e = game.battle.enemy;
    for(const a of allies){
      if(game.battle.enemyHP<=0) break;
      const base = Math.max(2, (a.atk||0) + Math.round(a.level*1.2));
      const def = applyEnemyDefDown(e.def||0);
      let dmg = Math.max(1, Math.round(base*(0.75+Math.random()*0.55) - def*0.20));
      if(Math.random()<0.06){ dmg = Math.round(dmg*1.6); game.battle.log.push("ü§ù <b>CRIT!</b>"); }
      game.battle.enemyHP = Math.max(0, game.battle.enemyHP - dmg);
      checkEnemyThresholds();
      game.battle.log.push(`ü§ù ${a.name} h·ªó tr·ª£ ƒë√°nh: <b>${dmg}</b> s√°t th∆∞∆°ng.`);
    }
  }
  function applyPlayerBuffs(){
    const ps = game.battle.statuses;
    const out = {STR:1, DEX:1, INT:1};
    for(const k of ["STR","DEX","INT"]){
      if(ps["buff_"+k] && ps["buff_"+k].turns>0) out[k] += ps["buff_"+k].pct;
    }
    return out;
  }
  function applySkillMpCost(skill){
    const base = skill.mp || 0;
    const mult = (game.player._derived?.mods?.mpCostMult || 1);
    return Math.max(0, Math.ceil(base * mult));
  }


  function checkEnemyThresholds(){
    const e = game.battle.enemy;
    if(!e) return;

    // Boss Hero t·∫ßng 100: d∆∞·ªõi 100 HP -> b·∫•t t·ª≠ 2 l∆∞·ª£t (1 l·∫ßn)
    if(e.immortalThreshold && !e.immortalTriggerUsed && game.battle.enemyHP <= e.immortalThreshold){
      e.immortalTriggerUsed = true;
      e.immortalTurns = Math.max(e.immortalTurns||0, 2);
      game.battle.enemyHP = Math.max(1, game.battle.enemyHP);
      game.battle.log.push(`<b>${e.name}</b> k√≠ch ho·∫°t <b>B·∫§T T·ª¨</b> 2 l∆∞·ª£t!`);
    }
  }

  function castSkill(skillId){
    if(!game.battle.active) return;
    if(game.battle.turn !== "player") return;

    const p = game.player;
    const e = game.battle.enemy;
    const skill = skillById(skillId);
    if(!skill) return;

    const cdLeft = game.battle.cds[skillId] || 0;
    if(cdLeft > 0){ game.battle.log.push("Skill ƒëang cooldown."); renderAll(); return; }

    computeStats(false);
    const mpCost = applySkillMpCost(skill);
    if(p.stats.MP < mpCost){ game.battle.log.push("Kh√¥ng ƒë·ªß MP."); renderAll(); return; }
    p.stats.MP -= mpCost;
    if((skill.cd||0) > 0) game.battle.cds[skillId] = skill.cd;

    playSlash(); shake($battleBar);

    const buffs = applyPlayerBuffs();
    const dmgMult = (p._derived?.dmgMult || 1);
    const ultBoost = (skill.kind==="ultimate") ? 1.25 : 1.0;
    if(skill.kind==="ultimate") game.battle.log.push("‚ú® <b>ULTIMATE</b> b√πng n·ªï!");

    if(skill.type==="heal"){
      let heal = skill.extra?.healFull ? (p.max.HP) : Math.max(1, Math.floor(p.max.HP * (skill.extra?.healPct || 0.20)));
      heal = Math.max(1, Math.floor(heal * ultBoost));
      if(e.noHealOpponent){
        game.battle.log.push(`<b>${e.name}</b> kh√≥a h·ªìi m√°u! B·∫°n kh√¥ng th·ªÉ h·ªìi HP.`);
      }else{
        p.stats.HP = clamp(p.stats.HP + heal, 0, p.max.HP);
        game.battle.log.push(`B·∫°n d√πng <b>${skill.name}</b> (+${heal} HP).`);
      }
    } else if(skill.type==="shield"){
      const pct = (skill.extra?.shieldPct || 0.20);
      const turns = (skill.extra?.shieldTurns || 2);
      let shield = Math.max(1, Math.floor(p.max.HP * pct));
      shield = Math.max(1, Math.floor(shield * (skill.kind==="ultimate" ? 1.20 : 1.0)));
      game.battle.shieldHP = Math.max(game.battle.shieldHP, shield);
      game.battle.statuses.shield = {turns};
      game.battle.log.push(`B·∫°n d·ª±ng <b>${skill.name}</b> (Shield ${shield} / ${turns} l∆∞·ª£t).`);
      if(skill.extra?.cleanse){ game.battle.statuses = {}; game.battle.log.push("Hi·ªáu ·ª©ng x·∫•u ƒë∆∞·ª£c g·ªôt r·ª≠a."); }
    } else if(skill.type==="buff"){
      game.battle.log.push(`B·∫°n d√πng <b>${skill.name}</b>.`);
      if(skill.extra?.extraTurn) game.battle.statuses.extraTurn = {turns:1};
      if(skill.extra?.mpFull){ p.stats.MP = p.max.MP; game.battle.log.push("MP h·ªìi ƒë·∫ßy."); }
      if(skill.extra?.guard){ game.battle.guard = true; game.battle.log.push("Nh·∫≠n Guard (gi·∫£m m·∫°nh s√°t th∆∞∆°ng 1 ƒë√≤n)."); }
      const stat = skill.extra?.buffStat || "STR";
      const pct0 = skill.extra?.buffPct || 0.20;
      const pct = pct0 * (skill.kind==="ultimate" ? 1.15 : 1.0);
      const turns = skill.extra?.buffTurns || 2;
      game.battle.statuses["buff_"+stat] = {pct, turns};
      game.battle.log.push(`TƒÉng ${stat} ${Math.round(pct*100)}% (${turns} l∆∞·ª£t).`);
    } else if(skill.type==="debuff"){
      const pierce = (skill.extra?.pierce || 0) + (p._derived?.pierceBonus || 0);
      const critP = (skill.extra?.crit || 0) + (p._derived?.critBonus || 0);
      const pure = !!skill.extra?.pure;

      const scaleStat = skill.scale || "STR";
      const scale = Math.round((p.stats[scaleStat] || p.stats.STR) * (buffs[scaleStat] || 1));
      const att = Math.round((scale + (p._derived?.atk||0) + Math.floor(p.stats.DEX/4)) * (skill.mult||1) * dmgMult * ultBoost);

      let def = applyEnemyDefDown(e.def);
      let dmg = dmgFormula(att, def, pierce, pure);
      if(Math.random() < (critP * (p._derived?.mods?.critMult || 1))){ dmg = Math.round(dmg * 1.6); game.battle.log.push("<b>CRIT!</b>"); }
      game.battle.enemyHP = Math.max(0, game.battle.enemyHP - dmg);
      checkEnemyThresholds();
      game.battle.log.push(`B·∫°n d√πng <b>${skill.name}</b> g√¢y <b>${dmg}</b> s√°t th∆∞∆°ng.`);

      const pct = skill.extra?.defDown || 0.18;
      const turns = skill.extra?.debuffTurns || 2;
      if(e.debuffImmune){
        game.battle.log.push(`${e.name} mi·ªÖn nhi·ªÖm hi·ªáu ·ª©ng x·∫•u!`);
      }else{
        game.battle.enemyStatuses.defDown = {pct, turns};
        game.battle.log.push(`DEF qu√°i gi·∫£m ${Math.round(pct*100)}% (${turns} l∆∞·ª£t).`);
      }
    } else {
      const pierce = (skill.extra?.pierce || 0) + (p._derived?.pierceBonus || 0);
      const critP = (skill.extra?.crit || 0) + (p._derived?.critBonus || 0);
      const pure = !!skill.extra?.pure;

      const scaleStat = skill.scale || "STR";
      const scale = Math.round((p.stats[scaleStat] || p.stats.STR) * (buffs[scaleStat] || 1));
      const att = Math.round((scale + (p._derived?.atk||0) + Math.floor(p.stats.DEX/4)) * (skill.mult||1) * dmgMult * ultBoost);

      let def = applyEnemyDefDown(e.def);
      let dmg = dmgFormula(att, def, pierce, pure);
      if(Math.random() < (critP * (p._derived?.mods?.critMult || 1))){ dmg = Math.round(dmg * 1.6); game.battle.log.push("<b>CRIT!</b>"); }
      game.battle.enemyHP = Math.max(0, game.battle.enemyHP - dmg);
      checkEnemyThresholds();
      game.battle.log.push(`B·∫°n d√πng <b>${skill.name}</b> g√¢y <b>${dmg}</b> s√°t th∆∞∆°ng.`);

      if(skill.type==="drain"){
        const ls = skill.extra?.lifesteal || 0.22;
        const heal = Math.max(1, Math.floor(dmg * ls));
        if(e.noHealOpponent){
          game.battle.log.push(`<b>${e.name}</b> kh√≥a h·ªìi m√°u! H√∫t m√°u b·ªã v√¥ hi·ªáu.`);
        }else{
          p.stats.HP = clamp(p.stats.HP + heal, 0, p.max.HP);
          game.battle.log.push(`H√∫t <b>+${heal} HP</b>.`);
        }
      }
      if(skill.type==="poison"){
        const pct = skill.extra?.dotPct || 0.08;
        const turns = skill.extra?.dotTurns || 2;
        if(e.debuffImmune){
          game.battle.log.push(`${e.name} mi·ªÖn nhi·ªÖm hi·ªáu ·ª©ng x·∫•u!`);
        }else{
          game.battle.enemyStatuses.poison = {pct, turns};
          game.battle.log.push(`G·∫Øn ƒë·ªôc (${turns} l∆∞·ª£t).`);
        }
      }
      if(skill.type==="stun"){
        const chance = skill.extra?.stunChance || 0.25;
        if(e.debuffImmune){
          game.battle.log.push(`${e.name} mi·ªÖn nhi·ªÖm hi·ªáu ·ª©ng x·∫•u!`);
        }else{
          if(Math.random() < chance){ game.battle.enemyStatuses.stunned = {turns:1}; game.battle.log.push("Qu√°i b·ªã <b>cho√°ng</b>!"); }
        }
      }
    }

    if(game.battle.enemyHP <= 0){
      const enraged = tryEnrageInsteadOfDeath();
      if(enraged){

    alliesAssistAttack();

    game.battle.turn = "enemy";
    renderAll();
        setTimeout(()=>enemyTurn(), 650);
        return;
      }
      renderAll();
      endBattle(true);
      return;
    }

    game.battle.turn = "enemy";
    renderAll();
    if(game.battle.statuses.extraTurn && game.battle.statuses.extraTurn.turns>0){
      delete game.battle.statuses.extraTurn;
      game.battle.turn = "player";
      game.battle.log.push("B·∫°n c√≥ <b>th√™m 1 l∆∞·ª£t</b>!");
      renderAll();
      return;
    }
    setTimeout(()=>enemyTurn(), 550);
  }

  function enemyTurn(){
    if(!game.battle.active) return;
    computeStats(false);
    const p = game.player;
    const e = game.battle.enemy;

    tickEnemyDots();
    if(game.battle.enemyHP <= 0){
      const enraged = tryEnrageInsteadOfDeath();
      if(enraged){ game.battle.turn = "enemy"; renderAll(); setTimeout(()=>enemyTurn(), 650); return; }
      renderAll(); endBattle(true); return;
    }

    if(e.justEnraged){
      e.justEnraged = false;
      game.battle.log.push(`${e.name} ƒëang g·∫ßm‚Ä¶ nh∆∞ng ch∆∞a t·∫•n c√¥ng!`);
      game.battle.turn = "player";
      renderAll();
      return;
    }

    if(game.battle.enemyStatuses.stunned && game.battle.enemyStatuses.stunned.turns > 0){
      game.battle.enemyStatuses.stunned.turns -= 1;
      game.battle.log.push(`${e.name} b·ªã <b>cho√°ng</b> v√† m·∫•t l∆∞·ª£t!`);
      game.battle.turn = "player";
      renderAll();
      return;
    }

    for(const k of Object.keys(game.battle.cds)){
      game.battle.cds[k] = Math.max(0, game.battle.cds[k]-1);
      if(game.battle.cds[k]===0) delete game.battle.cds[k];
    }
    decBuffs();

    // Passive c·ªßa boss: B·∫§T T·ª¨ m·ªói 6 l∆∞·ª£t (Boss Trial Th·∫ßn)
    if(e.immortalEvery){
      e.turnsTaken = (e.turnsTaken||0) + 1;
      if(e.turnsTaken % e.immortalEvery === 0){
        e.immortalTurns = Math.max(e.immortalTurns||0, 1);
        game.battle.log.push(`<b>${e.name}</b> nh·∫≠n <b>B·∫§T T·ª¨</b> 1 l∆∞·ª£t!`);
      }
    }

    // Passive H·ª¶Y DI·ªÜT: m·ªói l∆∞·ª£t l·∫•y 1 th√†nh ph·∫ßn c·ªßa player
    if(e.passiveDestruction){
      const stolen = stealOneComponentFromPlayer(e);
      if(stolen){
        game.battle.log.push(`<b>${e.name}</b> d√πng <b>H·ª¶Y DI·ªÜT</b> v√† c∆∞·ªõp <b>${stolen.kind}</b>: <b>${stolen.name}</b>!`);
        addLog(`‚ò†Ô∏è H·ªßy Di·ªát: m·∫•t ${stolen.kind} (${stolen.name}).`);
        computeStats(false);
      }else{
        game.battle.log.push(`<b>${e.name}</b> d√πng <b>H·ª¶Y DI·ªÜT</b> nh∆∞ng b·∫°n kh√¥ng c√≤n g√¨ ƒë·ªÉ m·∫•t‚Ä¶`);
      }
    }

    let mult = 1.0;
    if(Math.random() < 0.15) mult = 1.25;
    const pDefTotal = (p.stats.DEF + (p._derived?.def||0)) * (p._derived?.mods?.dmgTakenMult || 1);
    let dmg = dmgFormula(Math.round(e.atk * mult), pDefTotal, 0.0, false);
    if(p._special?.maCuongEquipped) dmg = Math.max(1, Math.floor(dmg * 0.75));

    if(game.battle.guard){
      dmg = Math.max(1, Math.floor(dmg * 0.45));
      game.battle.guard = false;
      game.battle.log.push("B·∫°n <b>Guard</b>! S√°t th∆∞∆°ng gi·∫£m.");
    }

    if(game.battle.statuses.shield && game.battle.shieldHP > 0){
      const absorbed = Math.min(game.battle.shieldHP, dmg);
      game.battle.shieldHP -= absorbed;
      dmg -= absorbed;
      game.battle.log.push(`Shield h·∫•p th·ª• <b>${absorbed}</b>.`);
      if(game.battle.shieldHP <= 0){ delete game.battle.statuses.shield; game.battle.log.push("Shield v·ª°!"); }
    }

    let targetType = "player";
    let target = p;
    const allies = (game.player.party||[]).filter(a=>a.hp>0);
    if(allies.length && Math.random()<0.30){
      targetType = "ally";
      target = pick(allies);
    }

    if(dmg > 0){
      if(targetType==="player"){
        p.stats.HP = Math.max(0, p.stats.HP - dmg);
        game.battle.log.push(`${e.name} t·∫•n c√¥ng: <b>${dmg}</b> s√°t th∆∞∆°ng.`);
      }else{
        target.hp = Math.max(0, target.hp - dmg);
        game.battle.log.push(`${e.name} t·∫•n c√¥ng ƒë·ªìng ƒë·ªôi <b>${target.name}</b>: <b>${dmg}</b> s√°t th∆∞∆°ng.`);
        if(target.hp<=0){ game.battle.log.push(`ü§ù ${target.name} g·ª•c ng√£!`); }
      }
      shake($battleBar);
    } else {
      game.battle.log.push(`${e.name} t·∫•n c√¥ng nh∆∞ng kh√¥ng xuy√™n qua ƒë∆∞·ª£c.`);
    }

    if(p.stats.HP <= 0 && hasArtifact("hero_will") && !game.battle.heroWillUsed){
      game.battle.heroWillUsed = true;
      p.stats.HP = 1;
      game.battle.guard = true;
      game.battle.log.push("<b>√ù CH√ç ANH H√ôNG</b> b√πng l√™n! B·∫°n s·ªëng l·∫°i 1 HP v√† nh·∫≠n Guard.");
      addLog("<b>√ù Ch√≠ Anh H√πng</b> c·ª©u b·∫°n kh·ªèi c√°i ch·∫øt.");
    }
    if(p.stats.HP <= 0){ renderAll(); endBattle(false); return; }

    applyRegenEndTurn();
    game.battle.turn = "player";
    renderAll();
  }

  function openMenu(){ renderMenu(); showOverlay("overlayMenu"); }
  function closeMenu(){ $overlayMenu.style.display="none"; }

  function openTalk(){ $talkInput.value=""; showOverlay("overlayTalk"); setTimeout(()=> $talkInput.focus(), 50); }
  function closeTalk(){ $overlayTalk.style.display="none"; }

  function openInv(){ renderInv(); showOverlay("overlayInv"); }

  function openPassives(){
    const p = game.player;
    showOverlay("overlayPassives");
    $passiveListWrap.innerHTML = "";
    if(!p.passives.length){
      $passiveListWrap.innerHTML = `<div class="listItem"><div><div class="t">(Kh√¥ng c√≥)</div><div class="d">B·∫°n ch∆∞a c√≥ b·ªã ƒë·ªông.</div></div></div>`;
    }else{
      for(const id of p.passives){
        const ps = passiveById(id); if(!ps) continue;
        const div = document.createElement("div");
        div.className = "listItem";
        div.innerHTML = `<div><div class="t">${ps.name} <span class="tag">${ps.rarity||"common"}</span></div><div class="d">${ps.desc}</div></div>`;
        $passiveListWrap.appendChild(div);
      }
    }
    const wk = weakness();
    $weaknessWrap.innerHTML = wk
      ? `<div class="listItem"><div><div class="t">${wk.name}</div><div class="d">${wk.desc}</div></div></div>`
      : `<div class="listItem"><div><div class="t">(Kh√¥ng c√≥)</div><div class="d">Kh√¥ng c√≥ nh∆∞·ª£c.</div></div></div>`;
  }

  function openProfession(){
    const p = game.player;
    const prof = professionById(p.professionId);
    showOverlay("overlayProfession");
    $professionWrap.innerHTML = `
      <div class="listItem">
        <div>
          <div class="t">${prof.name} <span class="tag">${prof.rarity}</span></div>
          <div class="d">${prof.perk}</div>
          <div class="d">Bonus: <b>${fmtBonus(prof.bonus||{})}</b></div>
        </div>
      </div>`;
  }

  function showCinematic(title, sub){
    $cinTitle.textContent = title;
    $cinSub.textContent = sub || "";
    $cinematic.style.display = "flex";
    setTimeout(()=>{ $cinematic.style.display = "none"; }, 900);
  }


  function closeInv(){ $overlayInv.style.display="none"; }

  function renderTravelMenu(){
    computeStats(false);
    const p = game.player;
    $menuChips.innerHTML = `
      <span class="tag">üìç ${p.location}</span>
      <span class="tag">Th·ªÉ l·ª±c ${p.stamina}/${p.maxStamina}</span>
      <span class="tag">V√†ng ${p.gold}</span>
      <span class="tag">üïØÔ∏è Souls ${(p.souls||0)}</span>`;
    $menuHint.textContent = "Ch·ªçn ƒë·ªãa ƒëi·ªÉm ƒë·ªÉ di chuy·ªÉn (kh√¥ng random).";
    $menuGrid.innerHTML = "";
    const items = [
      ...LOCATIONS.map(loc=>({t:loc, d:"", fn: ()=> doTravelTo(loc)})),
      {t:"‚¨ÖÔ∏è Back", d:"Quay l·∫°i menu ch√≠nh.", fn: ()=> renderMenu()},
    ];
    for(const it of items){
      const card = document.createElement("div");
      card.className = "menuCard";
      card.innerHTML = `<div class="t">${it.t}</div><div class="d">${it.d||""}</div>`;
      card.addEventListener("click", it.fn);
      $menuGrid.appendChild(card);
    }
  }

  function doTravelTo(dest){
    if(!preAction(2, "du h√†nh")) return;
    game.player.location = dest;
    applyLocationEnter();
    const npc = forcedNpc || currentNPC();
    pushStory(`B·∫°n di chuy·ªÉn t·ªõi <b>${dest}</b>. B·∫°n b·∫Øt g·∫∑p ${npc.name} (${npc.role}).`);
    addLog(`Travel t·ªõi <b>${dest}</b>.`);
    countAction();
    renderAll();
    closeMenu();
  }

  function openTravel(){
    // M·ªü ch·ªçn ƒë·ªãa ƒëi·ªÉm, ch·ªâ tr·ª´ th·ªÉ l·ª±c khi player x√°c nh·∫≠n n∆°i ƒë·∫øn.
    renderTravelMenu();
    showOverlay("overlayMenu");
  }

    /** ===================== Gamble (Ch·∫µn/L·∫ª) ===================== **/
  function openGamble(){
        game.gamble = game.gamble || {choice:null};
    game.gamble.choice = null;
    $gambleAnimText.textContent = "READY";
    $gambleResult.textContent = "";
    if($gambleChoiceTag) $gambleChoiceTag.textContent = "(ch∆∞a ch·ªçn)";
    $btnGambleEven?.classList.remove("btnPrimary");
    $btnGambleOdd?.classList.remove("btnPrimary");
    showOverlay("overlayGamble");
  }
  $btnCloseGamble?.addEventListener("click", ()=> $overlayGamble.style.display = "none");

  function setGambleChoice(choice){
    game.gamble.choice = choice;
    if($gambleChoiceTag) $gambleChoiceTag.textContent = `ƒê√£ ch·ªçn: ${choice==="even"?"Ch·∫µn":"L·∫ª"}`;
    if(choice==="even"){
      $btnGambleEven?.classList.add("btnPrimary"); $btnGambleOdd?.classList.remove("btnPrimary");
    }else{
      $btnGambleOdd?.classList.add("btnPrimary"); $btnGambleEven?.classList.remove("btnPrimary");
    }
  }
  $btnGambleEven?.addEventListener("click", ()=> setGambleChoice("even"));
  $btnGambleOdd?.addEventListener("click", ()=> setGambleChoice("odd"));

  function spinGamble(cb){
    let t=0;
    const timer = setInterval(()=>{
      t++;
      const n = randInt(0, 9);
      $gambleAnimText.textContent = String(n);
      if(t>14){ clearInterval(timer); cb(n); }
    }, 65);
  }

  $btnGambleRoll?.addEventListener("click", ()=>{
    if(!game.started || game.gameOver) return;
    const bet = Math.floor(Number($gambleBet.value||0));
    if(!Number.isFinite(bet) || bet<=0){ $gambleResult.textContent = "C·ªçc kh√¥ng h·ª£p l·ªá."; addLog("Gamble: c·ªçc kh√¥ng h·ª£p l·ªá."); return; }
    if(game.player.gold < bet){ $gambleResult.textContent = "Kh√¥ng ƒë·ªß v√†ng."; addLog("Gamble: kh√¥ng ƒë·ªß v√†ng."); return; }
    if(!game.gamble?.choice){ $gambleResult.textContent = "H√£y ch·ªçn Ch·∫µn ho·∫∑c L·∫ª."; return; }

    // Tr·ª´ ti·ªÅn c·ªçc tr∆∞·ªõc (an to√†n)
    game.player.gold -= bet;

    spinGamble((n)=>{
      // C∆° ch·∫ø th·∫Øng theo ti·ªÅn c·ªçc:
      // - Bet < 100: 70% h·ªá th·ªëng "roll" ra k·∫øt qu·∫£ gi√∫p b·∫°n th·∫Øng
      // - Bet >= 100: 0.1% roll ra k·∫øt qu·∫£ gi√∫p b·∫°n th·∫Øng
      const winChance = (bet < 100) ? 0.70 : 0.001;
      const win = (Math.random() < winChance);
      const forcedSide = win ? game.gamble.choice : (game.gamble.choice==="even"?"odd":"even");
      const n2 = (forcedSide==="even") ? pick([0,2,4,6,8]) : pick([1,3,5,7,9]);
      const side = forcedSide;
      if(win){
        const gain = bet * 10;
        game.player.gold += gain;
        $gambleAnimText.textContent = `${n2} (${side==="even"?"Ch·∫µn":"L·∫ª"})`;
        $gambleResult.innerHTML = `üé∞ <b>TR√öNG!</b> Nh·∫≠n <b>+${gain}</b> v√†ng.`;
        pushStory(`üé∞ B·∫°n gamble tr√∫ng (${side==="even"?"Ch·∫µn":"L·∫ª"}) v√† nh·∫≠n <b>+${gain}</b> v√†ng!`);
        addLog(`üé∞ Gamble tr√∫ng: +${gain} v√†ng.`);
        onQuestEvent('gamble_win', 1);
      }else{
        // m·∫•t 70% ti·ªÅn c∆∞·ª£c (t·ª©c m·∫•t 70% bet), b·∫°n ƒë√£ tr·ª´ bet tr∆∞·ªõc n√™n ho√†n l·∫°i 30%
        const refund = Math.floor(bet * 0.30);
        game.player.gold += refund;
        const loss = bet - refund;
        $gambleAnimText.textContent = `${n2} (${side==="even"?"Ch·∫µn":"L·∫ª"})`;
        $gambleResult.innerHTML = `üé∞ <b>TR∆Ø·ª¢T!</b> M·∫•t <b>${loss}</b> v√†ng (70%).`;
        pushStory(`üé∞ B·∫°n gamble tr∆∞·ª£t (${side==="even"?"Ch·∫µn":"L·∫ª"}). M·∫•t <b>${loss}</b> v√†ng.`);
        addLog(`üé∞ Gamble tr∆∞·ª£t: -${loss} v√†ng.`);
      }
      onQuestEvent('gamble_play', 1);
      countAction("gamble");
      computeStats(false);
      renderAll();
    });
  });

  function doMoney(){
    if(!preAction(2, "ki·∫øm ti·ªÅn")) return;
    computeStats(false);
    const p = game.player;
    const roll = Math.max(p.stats.CHA, p.stats.INT) + randInt(1,10);
    let earned = (roll >= 18) ? randInt(80, 140)
               : (roll >= 14) ? randInt(55, 95)
               : (roll >= 11) ? randInt(35, 65)
               : randInt(22, 44);
    earned = Math.floor(earned * 2.2 * (p._derived?.goldMult || 1) * (p._derived?.mods?.goldMult || 1));
    if(Math.random() < 0.12){ earned = Math.floor(earned * 0.35); pushStory("B·∫°n b·ªã qu·ªµt l∆∞∆°ng‚Ä¶ ch·ªâ nh·∫≠n ƒë∆∞·ª£c m·ªôt ph·∫ßn."); }
    p.gold += earned;
    onQuestEvent('earn', earned);
    pushStory(`B·∫°n ki·∫øm ti·ªÅn ·ªü ${p.location}. Nh·∫≠n <b>+${earned} v√†ng</b>. (S·ªë d∆∞: ${p.gold})`);
    addLog(`Money: <b>+${earned} v√†ng</b>.`);
    countAction();
    renderAll();
  }

  function doBattle(){
    normalizeMode();
    if(!preAction(3, "chi·∫øn ƒë·∫•u")) return;
    if(game.battle.active) return;
    if(game.mode.kind !== "free") return;
    const special = specialEncounterEnemy();
    if(special){
      pushStory(`‚ö†Ô∏è B·∫°n g·∫∑p <b>${special.name}</b>! (Boss Lv999)`);
      addLog(`G·∫∑p boss ƒë·∫∑c bi·ªát: <b>${special.name}</b>.`);
      countAction();
      startBattle(special, {kind:"normal"});
      return;
    }
    countAction();
    startBattle(spawnEnemy("normal", 1), {kind:"normal"});
  }

  function doNext(){
    normalizeMode();
    if(!preAction(3, "ƒëi ti·∫øp")) return;
    if(game.battle.active) return;
    if(!game.awaitingNext) return;
    const nxt = game.awaitingNext;
    if(nxt.kind === "dungeon"){
      game.dungeon.floor = nxt.nextFloor;
      game.awaitingNext = null;
      game.mode = {kind:"dungeon", hint:`Dungeon ${game.dungeon.name} (${game.dungeon.floor}/${game.dungeon.maxFloor})`};
      pushStory(`B·∫°n ti·∫øn v√†o dungeon t·∫ßng ${game.dungeon.floor}/${game.dungeon.maxFloor}.`);
      countAction();
      startBattle(spawnEnemy("dungeon", game.dungeon.floor), {kind:"dungeon", floor: game.dungeon.floor});
      return;
    }
    if(nxt.kind === "heroTrial"){
      game.heroTrial.floor = nxt.nextFloor;
      game.awaitingNext = null;
      game.mode = {kind:"heroTrial", hint:`Trial Anh H√πng t·∫ßng ${game.heroTrial.floor}/100`};
      pushStory(`B·∫°n ti·∫øn v√†o Trial Anh H√πng t·∫ßng ${game.heroTrial.floor}/100.`);
      countAction();
      startBattle(makeHeroTrialEnemy(game.heroTrial.floor), {kind:"heroTrial", floor: game.heroTrial.floor});
      return;
    }
    if(nxt.kind === "trial"){
      game.trial.floor = nxt.nextFloor;
      game.awaitingNext = null;
      game.mode = {kind:"trial", hint:`Trial ${godById(nxt.godId).name} t·∫ßng ${game.trial.floor}/50`};
      pushStory(`B·∫°n ti·∫øn v√†o Trial t·∫ßng ${game.trial.floor}/50.`);
      countAction();
      startBattle(makeTrialEnemy(game.trial.floor), {kind:"trial", godId:nxt.godId, floor: game.trial.floor});
      return;
    }
  }

  
  /** ===============================
   *  Quest System (NPC Talk)
   *  - Nh·∫Øn "nhi·ªám v·ª•" ƒë·ªÉ nh·∫≠n quest
   *  - Nh·∫Øn "tr·∫£ nhi·ªám v·ª•" / "nh·∫≠n th∆∞·ªüng" ƒë·ªÉ n·ªôp quest
   *  =============================== */
  const QUEST_MAX_ACTIVE = 3;
  const QUEST_RARITY_TABLE = [
    {id:"common",    w:70,  mult:1.0},
    {id:"rare",      w:20,  mult:1.8},
    {id:"legend",    w:8,   mult:3.5},
    {id:"legendary", w:2,   mult:7.0},
    {id:"mythic",    w:0.2, mult:15.0},
  ];

  function ensureQuests(){
    const p = game.player;
    p.quests ??= {active:[], completed:0};
    p.quests.active ??= [];
    p.quests.completed ??= 0;
  }

  function rollQuestRarity(){
    let sum = 0; for(const r of QUEST_RARITY_TABLE) sum += r.w;
    let x = Math.random() * sum;
    for(const r of QUEST_RARITY_TABLE){
      x -= r.w;
      if(x <= 0) return r.id;
    }
    return "common";
  }

  function questRarityMult(rarity){
    const r = QUEST_RARITY_TABLE.find(x=>x.id===rarity);
    return r ? r.mult : 1.0;
  }

  function questReward(rarity, difficulty){
    // difficulty th∆∞·ªùng l√† target ho·∫∑c level-ish
    const mult = questRarityMult(rarity);
    const gold = Math.floor((60 + difficulty*18) * mult);
    const exp  = Math.floor((40 + difficulty*14) * mult);
    return {gold, exp};
  }

  function createQuest(npc){
    ensureQuests();
    const p = game.player;
    const rarity = rollQuestRarity();

    const types = [
      {type:"kill",       label:"SƒÉn qu√°i",         base:3},
      {type:"earn",       label:"Ki·∫øm v√†ng",        base:120},
      {type:"gacha",      label:"M·ªü gacha",         base:1},
      {type:"gamble_win", label:"Gamble tr√∫ng",     base:1},
    ];
    const pickType = types[randInt(0, types.length-1)];

    let target = pickType.base;
    if(pickType.type==="kill"){
      target = clamp(Math.floor(2 + (p.level/8) + randInt(0,2)), 2, 12);
      target = Math.floor(target * questRarityMult(rarity));
      target = clamp(target, 2, 25);
    }else if(pickType.type==="earn"){
      target = clamp(Math.floor((80 + p.level*10) * questRarityMult(rarity)), 80, 6000);
      target = Math.floor(target / 10) * 10;
    }else if(pickType.type==="gacha"){
      target = clamp(Math.floor(1 * questRarityMult(rarity)), 1, 50);
    }else if(pickType.type==="gamble_win"){
      target = clamp(Math.floor(1 * questRarityMult(rarity)), 1, 30);
    }

    const reward = questReward(rarity, Math.max(1, Math.floor(target/2)));
    let desc = "";
    if(pickType.type==="kill") desc = `H·∫° ${target} k·∫ª ƒë·ªãch.`;
    if(pickType.type==="earn") desc = `Ki·∫øm ƒë·ªß ${target} v√†ng (t√≠nh v√†ng ki·∫øm ƒë∆∞·ª£c).`;
    if(pickType.type==="gacha") desc = `M·ªü gacha ${target} l·∫ßn.`;
    if(pickType.type==="gamble_win") desc = `Gamble tr√∫ng ${target} l·∫ßn (Ch·∫µn/L·∫ª).`;

    return {
      id:"q_"+uid(),
      giverId:npc.id,
      giverName:npc.name,
      rarity,
      type:pickType.type,
      target,
      progress:0,
      done:false,
      reward,
      desc
    };
  }

  function addQuest(q){
    ensureQuests();
    const p = game.player;
    if(p.quests.active.length >= QUEST_MAX_ACTIVE) return false;
    p.quests.active.push(q);
    return true;
  }

  function questProgressText(q){
    return `${q.progress}/${q.target}`;
  }

  function onQuestEvent(type, amount){
    ensureQuests();
    const p = game.player;
    let changed = false;
    for(const q of p.quests.active){
      if(q.done) continue;
      if(q.type !== type) continue;
      q.progress = clamp(q.progress + (amount||0), 0, 999999999);
      if(q.progress >= q.target){
        q.progress = q.target;
        q.done = true;
        changed = true;
      }
    }
    if(changed){
      addLog(`üìú C√≥ nhi·ªám v·ª• ƒë√£ <b>ho√†n th√†nh</b>! (H√£y n√≥i v·ªõi NPC: "tr·∫£ nhi·ªám v·ª•")`);
    }
  }

  function tryTurnInQuests(npc){
    ensureQuests();
    const p = game.player;
    let turnedIn = 0;
    let gotGold = 0;
    let gotExp = 0;

    const remain = [];
    for(const q of p.quests.active){
      if(q.done && q.giverId === npc.id){
        turnedIn++;
        gotGold += (q.reward?.gold||0);
        gotExp  += (q.reward?.exp||0);
      }else{
        remain.push(q);
      }
    }
    p.quests.active = remain;

    if(turnedIn>0){
      p.gold += gotGold;
      grantExp(gotExp);
      // Bonus: Tensura scroll reward theo ƒë·ªô hi·∫øm quest
      const slimePoolByRarity = (rar)=> {
        if(rar==="mythic"||rar==="legendary") return ["scroll_great_sage","scroll_predator","scroll_beelzebuth","scroll_uriel","scroll_megido"];
        if(rar==="legend") return ["scroll_demon_lord_haki","tempest_emblem","scroll_predator"];
        if(rar==="rare") return ["tempest_emblem"];
        return [];
      };
      let slimeDrops = [];
      // gom t·∫•t c·∫£ quest ƒë√£ n·ªôp trong l·∫ßn n√†y ƒë·ªÉ roll th∆∞·ªüng ph·ª•
      for(const q of p.quests.active){ /* noop placeholder */ }
      // Roll theo s·ªë quest ƒë√£ n·ªôp, nh∆∞ng tr√°nh spam: t·ªëi ƒëa 1 m√≥n/l·∫ßn n·ªôp
      const allRarities = [];
      // (Rarities ƒë√£ b·ªã xo√° kh·ªèi active tr∆∞·ªõc ƒë√≥, n√™n d√πng turnedIn v√† ∆∞·ªõc l∆∞·ª£ng theo may m·∫Øn)
      // N·∫øu mu·ªën ch√≠nh x√°c theo t·ª´ng quest, c√≥ th·ªÉ m·ªü r·ªông sau.
      // T·∫°m: d√πng LUK ƒë·ªÉ tƒÉng nh·∫π c∆° h·ªôi.
      const luck = (p.stats.LUK||0);
      const chance = clamp(0.10 + luck*0.002, 0.10, 0.22);
      if(Math.random() < chance){
        // ∆∞u ti√™n pool x·ªãn n·∫øu b·∫°n n·ªôp >=2 quest
        const pool = (turnedIn>=2) ? slimePoolByRarity("legendary") : slimePoolByRarity("legend");
        if(pool.length){
          const it = pick(pool);
          if(itemMeta(it)){
            addStack(it, 1);
            slimeDrops.push(it);
          }
        }
      }
      if(slimeDrops.length){
        const names = slimeDrops.map(id=>itemMeta(id)?.name||id).join(", ");
        pushStory(`üå™Ô∏è Th∆∞·ªüng ph·ª• (Tensura): nh·∫≠n <b>${names}</b>.`);
        addLog(`üå™Ô∏è Th∆∞·ªüng ph·ª• Tensura: ${names}.`);
      }
      onQuestEvent('battle_win', 1);
      onQuestEvent('kill', 1);
      p.quests.completed += turnedIn;
      pushStory(`üìú N·ªôp ${turnedIn} nhi·ªám v·ª• cho ${npc.name}: nh·∫≠n <b>+${gotGold} v√†ng</b>, <b>+${gotExp} EXP</b>.`);
      addLog(`üìú N·ªôp nhi·ªám v·ª•: +${gotGold} v√†ng, +${gotExp} EXP.`);
      return `T·ªët. ƒê√¢y l√† th∆∞·ªüng: +${gotGold} v√†ng, +${gotExp} EXP.`;
    }
    return null;
  }

  function handleQuestTalk(npc, normText){
    ensureQuests();
    const p = game.player;

    // Tensura keyword: m·ªü "g√≥i Slime" (l·∫•y c·∫£m h·ª©ng) ‚Äî t·∫∑ng 2 skill core 1 l·∫ßn
    p._tensura ??= {gifted:false};
    if(!p._tensura.gifted){
      const t = normText;
      if(t.includes("slime") || t.includes("rimuru") || t.includes("tempest") || t.includes("veldora") || t.includes("tensei") || t.includes("tensura")){
        p._tensura.gifted = true;
        addStack("scroll_great_sage", 1);
        addStack("scroll_predator", 1);
        addStack("tempest_emblem", 1);
        pushStory(`üå™Ô∏è B·∫°n nghe nh·∫Øc t·ªõi Tempest‚Ä¶ Th·∫ø gi·ªõi ƒë√°p l·∫°i.
Nh·∫≠n: <b>Cu·ªôn Great Sage</b>, <b>Cu·ªôn Predator</b>, <b>Huy Hi·ªáu Tempest</b>.
(D√πng trong Inventory ƒë·ªÉ h·ªçc skill.)`);
        addLog("üå™Ô∏è Tensura Pack unlocked: t·∫∑ng 2 skill core + huy hi·ªáu.");
        return `"Ng∆∞∆°i‚Ä¶ nghe th·∫•y 'Voice of the World' sao? Ta trao cho ng∆∞∆°i 2 cu·ªôn k·ªπ nƒÉng v√† 1 huy hi·ªáu. H√£y d√πng trong Inventory."`;
      }
    }


    if(normText.includes("tra nhiem vu") || normText.includes("nop nhiem vu") || normText.includes("nhan thuong")){
      const rep = tryTurnInQuests(npc);
      return rep || `"B·∫°n kh√¥ng c√≥ nhi·ªám v·ª• ho√†n th√†nh ƒë·ªÉ n·ªôp cho t√¥i."`;
    }

    if(normText.includes("nhiem vu") || normText.includes("quest")){
      if(p.quests.active.length >= QUEST_MAX_ACTIVE){
        const list = p.quests.active.map(q=>`‚Ä¢ [${q.rarity}] ${q.desc} (${questProgressText(q)})`).join("\\n");
        return `"B·∫°n ƒëang c√≥ qu√° nhi·ªÅu nhi·ªám v·ª•.\\n${list || "(tr·ªëng)"}\\nH√£y ho√†n th√†nh r·ªìi quay l·∫°i."`;
      }
      const q = createQuest(npc);
      addQuest(q);
      pushStory(`üìú Nh·∫≠n nhi·ªám v·ª• (${rarityLabel(q.rarity)}): ${q.desc} ‚Ä¢ Th∆∞·ªüng: +${q.reward.gold} v√†ng, +${q.reward.exp} EXP. (N√≥i: "tr·∫£ nhi·ªám v·ª•" ƒë·ªÉ nh·∫≠n th∆∞·ªüng)`);
      addLog(`üìú Nh·∫≠n nhi·ªám v·ª•: <b>${q.desc}</b>.`);
      return `"ƒê√¢y. Nhi·ªám v·ª•: ${q.desc} (Ti·∫øn ƒë·ªô ${questProgressText(q)}). Th∆∞·ªüng: +${q.reward.gold} v√†ng, +${q.reward.exp} EXP."`;
    }

    return null;
  }

  function npcReplyAndEvent(playerText, forcedNpc=null){
    const npc = forcedNpc || currentNPC();
    const t = normalize(playerText);
    const questReply = handleQuestTalk(npc, t);
    if(questReply){
      return {npc, reply: questReply, eventText:null};
    }

    // ===== Tensura-like commands (progression) =====
    if(t.includes("thuc tinh") || t.includes("th·ª©c t·ªânh")){
      const av = availableEvolutions();
      const awaken = av.find(x=>x.to==="true_demon_lord");
      if(awaken){
        doEvolve("true_demon_lord");
        return {npc, reply:`"üî• Ma l·ª±c h·ªôi t·ª•‚Ä¶ Ng∆∞∆°i ƒë√£ <b>th·ª©c t·ªânh</b>."`, eventText:null};
      }
      return {npc, reply:`"Ng∆∞∆°i ch∆∞a ƒë·ªß ƒëi·ªÅu ki·ªán ƒë·ªÉ th·ª©c t·ªânh. (G·ª£i √Ω: Lv‚â•60, 100 Souls, Demon Lord Seed)"`, eventText:null};
    }

    if(t.startsWith("dat ten ") || t.startsWith("ƒë·∫∑t t√™n ")){
      const title = playerText.replace(/^(dat ten|ƒë·∫∑t t√™n)\s+/i,"").trim();
      if(doNameSelf(title)){
        return {npc, reply:`"Ta ghi nh·∫≠n danh x∆∞ng: <b>${escapeHtml(title)}</b>."`, eventText:null};
      }
      return {npc, reply:`"Ng∆∞∆°i ch∆∞a th·ªÉ nh·∫≠n danh x∆∞ng. (G·ª£i √Ω: c√≥ Great Sage ho·∫∑c Voice of the World)"`, eventText:null};
    }

    if(t.includes("tien hoa") || t.includes("ti·∫øn h√≥a") || t.includes("ti·∫øn ho√°") || t.includes("tien ho√°") || t.includes("evolve")){
      const av = availableEvolutions();
      if(!av.length){
        return {npc, reply:`"Kh√¥ng c√≥ ti·∫øn h√≥a ph√π h·ª£p l√∫c n√†y."`, eventText:null};
      }
      // N·∫øu c√≥ nhi·ªÅu ti·∫øn h√≥a, ∆∞u ti√™n c√°i ƒë·∫ßu ti√™n
      const pickE = av[0];
      doEvolve(pickE.to);
      return {npc, reply:`"üåÄ ${pickE.title}. ( ${pickE.desc.replace(/<[^>]+>/g,"")} )"`, eventText:null};
    }

    const traits = new Set(npc.traits.map(normalize));
    const mood = npc.stats.mood;
    const empathy = npc.stats.empathy;
    const greed = npc.stats.greed;
    const temper = npc.stats.temper;
    const cunning = npc.stats.cunning;

    let tone = "b√¨nh th·∫£n";
    if(traits.has("coc can") || temper > 70) tone = "c·ªôc c·∫±n";
    if(traits.has("hien lanh") || empathy > 70) tone = "hi·ªÅn";
    if(traits.has("bi hiem") || cunning > 75) tone = "b√≠ hi·ªÉm";
    if(mood > 35) tone = "vui v·∫ª";
    if(mood < -10) tone = "kh√≥ ch·ªãu";

    const intents = [
      {id:"greet", keys:["xin","chao","hello","hi","hey"]},
      {id:"ask", keys:["hoi","ban biet","o dau","lam sao","tai sao","giup","chi"]},
      {id:"buy", keys:["mua","ban","gia","doi","giao dich","hang","vat pham","shop"]},
      {id:"threat", keys:["de doa","giet","dam","cuop","neu khong"]},
      {id:"joke", keys:["dua","hai","haha","lol"]},
      {id:"flirt", keys:["dep","thuong","nho","yeu","xinh","thich"]},
    ];
    let best = {id:"neutral", score:0};
    for(const it of intents){
      let hit = 0;
      for(const k of it.keys){ if(t.includes(normalize(k))) hit++; }
      const sc = hit / it.keys.length;
      if(sc > best.score) best = {id:it.id, score: sc};
    }
    const intent = (best.score >= 0.12) ? best.id : "neutral";

    let reply = "";
    if(intent==="greet"){
      reply = (tone==="c·ªôc c·∫±n") ? `"·ª™‚Ä¶ ch√†o."` : (tone==="b√≠ hi·ªÉm") ? `"Ch√†o. ·ªû ƒë√¢y ƒë√™m d√†i l·∫Øm."` : `"Ch√†o b·∫°n. ƒêi ƒë·ª©ng c·∫©n th·∫≠n."`;
      npc.stats.mood = clamp(npc.stats.mood + 2, -50, 110);
    } else if(intent==="buy"){
      reply = (greed > 65 || traits.has("tham lam")) ? `"C√≥ h√†ng. Nh∆∞ng gi√° kh√¥ng r·∫ª."` : `"N·∫øu mu·ªën mua, v√†o shop ƒëi."`;
      npc.stats.mood = clamp(npc.stats.mood + 1, -50, 110);
    } else if(intent==="ask"){
      if((empathy + mood) > 50) reply = `"Nghe n√≥i c√≥ dungeon. N·∫øu ƒë·ªß m·∫°nh, th·ª≠ ƒëi."`;
      else reply = (tone==="c·ªôc c·∫±n") ? `"T√¥i b·∫≠n."` : `"Kh√¥ng r√µ. Ai c≈©ng gi·ªØ m·ªìm."`;
      npc.stats.mood = clamp(npc.stats.mood + ((empathy+mood)>50 ? 1 : -1), -50, 110);
    } else if(intent==="threat"){
      reply = (npc.stats.courage < 40) ? `"ƒê-ƒë∆∞·ª£c r·ªìi‚Ä¶ b√¨nh tƒ©nh."` : `"Th·ª≠ xem."`;
      npc.stats.mood = clamp(npc.stats.mood - 4, -50, 110);
      game.world.heat = clamp(game.world.heat + 6, 0, 100);
    } else if(intent==="flirt"){
      reply = (tone==="vui v·∫ª" || empathy>55) ? `"B·∫°n n√≥i kh√©o qu√°."` : `"ƒê·ª´ng."`;
      npc.stats.mood = clamp(npc.stats.mood + (empathy>55 ? 3 : -2), -50, 110);
    } else if(intent==="joke"){
      reply = (tone==="c·ªôc c·∫±n") ? `"H√†i h∆∞·ªõc kh√¥ng c·ª©u m·∫°ng ƒë√¢u."` : `"Hi·∫øm ai c√≤n bi·∫øt ƒë√πa."`;
      npc.stats.mood = clamp(npc.stats.mood + 1, -50, 110);
    } else {
      if(traits.has("to mo")) reply = `"B·∫°n t·ª´ ƒë√¢u t·ªõi?"`;
      else if(traits.has("thuc dung")) reply = `"Ki·∫øm ti·ªÅn v√† n√¢ng ƒë·ªì."`;
      else if(traits.has("thich giup nguoi")) reply = `"N·∫øu k·∫πt, t√¥i ch·ªâ v√†i ƒë∆∞·ªùng."`;
      else reply = `"·ª™m."`;
      npc.stats.mood = clamp(npc.stats.mood + randInt(-1,2), -50, 110);
    }

    let eventText = null;
    if(Math.random() < 0.30) eventText = npcEvent(npc);
    return {npc, reply, eventText};
  }

  function npcEvent(npc){
    npc.eventStage = (npc.eventStage||0) + 1;
    if(Math.random() < 0.18 && (npc.stats.cunning > 65 || npc.traits.includes("tham lam"))){
      const lost = Math.floor(game.player.gold * 0.5);
      game.player.gold = Math.max(0, game.player.gold - lost);
      addLog(`NPC l·ª´a b·∫°n: <b>-${lost} v√†ng</b>.`);
      return `${npc.name} l·ª´a b·∫°n‚Ä¶ b·∫°n m·∫•t <b>${lost} v√†ng</b>!`;
    }
    if(npc.role === "th·∫ßy thu·ªëc"){
      const heal = randInt(10, 22);
      computeStats(false);
      game.player.stats.HP = clamp(game.player.stats.HP + heal, 0, game.player.max.HP);
      addLog(`NPC event: ${npc.name} ch·ªØa tr·ªã (+${heal} HP).`);
      return `${npc.name} ch·ªØa tr·ªã: h·ªìi <b>+${heal} HP</b>.`;
    }
    if(npc.role === "th·ª£ r√®n"){
      if(Math.random() < 0.5){
        addStack("ore", 2);
        addLog(`NPC event: ${npc.name} t·∫∑ng Qu·∫∑ng R√®n x2.`);
        return `${npc.name} t·∫∑ng <b>Qu·∫∑ng R√®n x2</b>.`;
      }
      return `${npc.name} th√¨ th·∫ßm: "T·ª´ +10 tr·ªü l√™n l√† ƒë·ªãa ng·ª•c."`;
    }
    if(npc.role === "th∆∞∆°ng nh√¢n"){
      const deal = randInt(20, 55);
      game.player.gold += deal;
      addLog(`NPC event: +${deal} v√†ng.`);
      return `${npc.name} ƒë∆∞a b·∫°n <b>+${deal} v√†ng</b>.`;
    }
    if(npc.role === "ch·ªß qu√°n") return `${npc.name}: "Mu·ªën h√†ng hi·∫øm‚Ä¶ h√£y <b>tip</b> trong shop."`;
    if(Math.random() < 0.25){
      const s = pick(ACTIVE_SKILLS.filter(x=>x.kind==="active"));
      learnSkill(s.id);
      addLog(`NPC d·∫°y skill: <b>${s.name}</b>.`);
      return `${npc.name} d·∫°y b·∫°n k·ªπ nƒÉng: <b>${s.name}</b>.`;
    }
    if(Math.random() < 0.35){
      addStack("potion", 1);
      addLog(`NPC event: ${npc.name} t·∫∑ng Thu·ªëc H·ªìi HP.`);
      return `${npc.name} t·∫∑ng b·∫°n <b>Thu·ªëc H·ªìi HP</b>.`;
    }
    return `${npc.name} k·ªÉ chuy·ªán‚Ä¶ v√† b·∫°n c·∫£m gi√°c th·∫ø gi·ªõi ƒëang chuy·ªÉn ƒë·ªông.`;
  }

  function doTalkSend(){
    if(!preAction(1, "n√≥i chuy·ªán")) return;
    const msg = ($talkInput.value||"").trim();
    if(!msg) return;
    closeTalk();
    computeStats(false);
    const p = game.player;
    const forcedNpc = currentNPC();
    const {npc, reply, eventText} = npcReplyAndEvent(msg, forcedNpc);
    const npcStats = `Mood ${npc.stats.mood} | Emp ${npc.stats.empathy} Greed ${npc.stats.greed} Temper ${npc.stats.temper} Courage ${npc.stats.courage} Cunning ${npc.stats.cunning}`;
    const meStats = `Lv ${p.level} | HP ${p.stats.HP}/${p.max.HP} MP ${p.stats.MP}/${p.max.MP} | STR ${p.stats.STR} DEX ${p.stats.DEX} INT ${p.stats.INT} CHA ${p.stats.CHA} LUK ${p.stats.LUK} DEF ${p.stats.DEF}`;
    pushStory(`B·∫°n n√≥i: "${msg}"\n${npc.name} (${npc.role}, ${npc.traits.join(", ")}): ${reply}\n\n[Ch·ªâ s·ªë] B·∫°n: ${meStats}\n[Ch·ªâ s·ªë] NPC: ${npcStats}${eventText ? `\n\n=== NPC EVENT ===\n${eventText}` : ""}`);
    addLog(`Talk v·ªõi <b>${npc.name}</b>.`);
    countAction();
    renderAll();
  }

  function renderInv(){
    computeStats(false);
    const p = game.player;
    const stacks = getStacks();
    const gears = getGears();
    const stackLines = stacks.map(it=>{
      const m = itemMeta(it.id);
      return `
        <div class="listItem">
          <div class="left">
            <div class="name">${m?m.name:it.id} <span class="rar ${m?.rarity||"common"}">${rarityLabel(m?.rarity||"common")}</span></div>
            <div class="desc">${m?.desc||"‚Äî"} ‚Ä¢ x${it.qty}</div>
          </div>
          <div style="text-align:right;">
            ${(m?.type==="consumable") ? `<button class="btn btnPrimary" data-use="${it.id}">D√πng</button>` : ""}
          </div>
        </div>`;
    }).join("");
    const gearLines = gears.map(g=>{
      const m = itemMeta(g.id); if(!m) return "";
      const enh = g.enh||0;
      const equipped = (p.equipped.weaponUid===g.uid || p.equipped.armorUid===g.uid);
      const statLine = (m.type==="weapon") ? `ATK ${m.atk||0} (+10^${enh})` : `DEF ${m.def||0} (+10^${enh})`;
      return `
        <div class="listItem">
          <div class="left">
            <div class="name">${m.name} <span class="rar ${m.rarity}">${rarityLabel(m.rarity)}</span> ${equipped?`<span class="rar common">Equipped</span>`:""}</div>
            <div class="desc">${statLine}</div>
          </div>
          <div style="text-align:right;">
            <button class="btn btnPrimary" data-eq="${g.uid}">Trang b·ªã</button>
          </div>
        </div>`;
    }).join("");
    const wk = weakness();
    const wkLine = wk ? `<span class="tag">${wk.name}: ${wk.desc}</span>` : `<span class="tag">Nh∆∞·ª£c: (kh√¥ng)</span>`;
    $invBody.innerHTML = `
      <div class="tagList">
        <span class="tag">V√†ng: ${p.gold}</span>
        <span class="tag">Lv: ${p.level}/${MAX_LV}</span>
        <span class="tag">HP: ${p.stats.HP}/${p.max.HP}</span>
        <span class="tag">MP: ${p.stats.MP}/${p.max.MP}</span>
        ${wkLine}
      </div>
      <div style="margin-top:10px;">
        <p class="sectionTitle">Consumable / Material</p>
        <div class="list">${stackLines || `<div class="mini">Kh√¥ng c√≥.</div>`}</div>
      </div>
      <div style="margin-top:12px;">
        <p class="sectionTitle">V≈© kh√≠ / Gi√°p</p>
        <div class="list">${gearLines || `<div class="mini">Kh√¥ng c√≥.</div>`}</div>
      </div>`;
    $invBody.querySelectorAll("[data-use]").forEach(btn=> btn.addEventListener("click", ()=> useItem(btn.getAttribute("data-use"))));
    $invBody.querySelectorAll("[data-eq]").forEach(btn=> btn.addEventListener("click", ()=> equipByUid(btn.getAttribute("data-eq"))));
  }
  function useItem(id){
    if(!preAction(1, "d√πng v·∫≠t ph·∫©m")) return;
    const meta = itemMeta(id);
    if(!meta || meta.type!=="consumable") return;
    if(!removeStack(id,1)) return;
    computeStats(false);
    if(meta.eff?.hp){ game.player.stats.HP = clamp(game.player.stats.HP + meta.eff.hp, 0, game.player.max.HP); pushStory(`B·∫°n d√πng ${meta.name}. (+${meta.eff.hp} HP)`); }
    else if(meta.eff?.mp){ game.player.stats.MP = clamp(game.player.stats.MP + meta.eff.mp, 0, game.player.max.MP); pushStory(`B·∫°n d√πng ${meta.name}. (+${meta.eff.mp} MP)`); }

    else if(meta.eff?.learnSkillId){
      learnSkill(meta.eff.learnSkillId);
      pushStory(`üìò B·∫°n d√πng ${meta.name} v√† h·ªçc: <b>${skillById(meta.eff.learnSkillId)?.name || meta.eff.learnSkillId}</b>.`);
      addLog(`H·ªçc skill m·ªõi: <b>${skillById(meta.eff.learnSkillId)?.name || meta.eff.learnSkillId}</b>.`);
    }
    else if(meta.eff?.learnPassiveId){
      if(!game.player.passives.includes(meta.eff.learnPassiveId)){
        game.player.passives.push(meta.eff.learnPassiveId);
        pushStory(`üìó B·∫°n d√πng ${meta.name} v√† nh·∫≠n b·ªã ƒë·ªông: <b>${passiveById(meta.eff.learnPassiveId)?.name || meta.eff.learnPassiveId}</b>.`);
        addLog(`Nh·∫≠n passive: <b>${passiveById(meta.eff.learnPassiveId)?.name || meta.eff.learnPassiveId}</b>.`);
      }else{
        pushStory(`üìó B·∫°n ƒë√£ c√≥ b·ªã ƒë·ªông n√†y r·ªìi.`);
      }
    }

    else if(meta.eff?.learnRandomSkill){
      const pool = ACTIVE_SKILLS.filter(s=>s.kind==="active");
      const owned = new Set(game.player.learnedSkills);
      const avail = pool.filter(s=>!owned.has(s.id));
      const picked = pick(avail.length?avail:pool);
      learnSkill(picked.id);
      pushStory(`üìò B·∫°n d√πng ${meta.name} v√† h·ªçc: <b>${picked.name}</b>.`);
      addLog(`H·ªçc skill m·ªõi: <b>${picked.name}</b>.`);
    }
    else if(meta.eff?.maxAge){
      game.player.maxAge = Math.max(1, (game.player.maxAge||100) + meta.eff.maxAge);
      pushStory(`B·∫°n d√πng ${meta.name}. Tu·ªïi th·ªç t·ªëi ƒëa: <b>${game.player.maxAge}</b>.`);
    }
    else if(meta.eff?.luckTurns){
      game.player.buffs = game.player.buffs || {luckTurns:0};
      game.player.buffs.luckTurns = Math.max(game.player.buffs.luckTurns||0, meta.eff.luckTurns);
      pushStory(`üçÄ B·∫°n d√πng ${meta.name}. Luck tƒÉng trong <b>${game.player.buffs.luckTurns} turn</b>.`);
      addLog(`üçÄ Luck Elixir: hi·ªáu l·ª±c ${game.player.buffs.luckTurns} turn.`);
    }
    addLog(`D√πng <b>${meta.name}</b>.`);
    countAction(); renderInv(); renderAll();
  }
  function equipByUid(gearUid){
    if(!preAction(1, "trang b·ªã")) return;
    const g = findGearByUid(gearUid);
    if(!g) return;
    const meta = itemMeta(g.id);
    if(!meta || (meta.type!=="weapon" && meta.type!=="armor")) return;
    if(meta.type==="weapon") game.player.equipped.weaponUid = g.uid;
    else game.player.equipped.armorUid = g.uid;
    addLog(`Equip <b>${meta.name} +${g.enh||0}</b>.`);
    pushStory(`B·∫°n trang b·ªã ${meta.name} +${g.enh||0}.`);
    countAction(); computeStats(false); renderInv(); renderAll();
  }

  const $choicesTitle = document.getElementById("choicesTitle");
  const $choicesHint = document.getElementById("choicesHint");
  const $choicesRow = document.getElementById("choicesRow");

  function setChoices(title, arr){
    $choicesTitle.textContent = title;
    $choicesRow.innerHTML = "";
    for(const c of arr){
      const btn = document.createElement("button");
      btn.className = "choiceBtn " + (c.kind||"");
      btn.textContent = c.label;
      btn.addEventListener("click", ()=> c.onClick());
      $choicesRow.appendChild(btn);
    }
  }
  function updateContextChoices(){
    if(game.battle.active){
      setChoices("battle", [
        {label:"Skills", kind:"warn", onClick: ()=> openSkills()},
        {label:"Inv", kind:"", onClick: ()=> openInv()},
      ]);
      $choicesHint.textContent = "d√πng 4 n√∫t skill b√™n d∆∞·ªõi";
      return;
    }
    const baseChoices = [
      {label:"Battle", kind:"bad", onClick: ()=> doBattle()},
      {label:"Talk", kind:"good", onClick: ()=> openTalk()},
      {label:"Money", kind:"warn", onClick: ()=> doMoney()},
      {label:"Shop", kind:"", onClick: ()=> openShop()},
      {label:"Gacha", kind:"", onClick: ()=> openGachaAndRoll()},
      {label:"Dungeon", kind:"bad", onClick: ()=> startDungeon()},
      {label:"Trial", kind:"", onClick: ()=> openTrial()},
      {label:"Gamble", kind:"", onClick: ()=> openGamble()},
      {label:"Travel", kind:"", onClick: ()=> openTravel()},
      {label:"Next", kind:"", onClick: ()=> doNext()},
    ];
    if(game.player.location === "Tensura"){
      baseChoices.splice(2,0,
        {label:"ƒê·∫ø ch·∫ø", kind:"good", onClick: ()=> openEmpire()},
        {label:"Ti·∫øn ho√°", kind:"warn", onClick: ()=> openEvolve()},
        {label:"Thu ph·ª•c", kind:"good", onClick: ()=> openRecruit()},
        {label:"ƒê·ªìng ƒë·ªôi", kind:"", onClick: ()=> openParty()},
      );
    }
    setChoices("h√†nh ƒë·ªông nhanh", baseChoices);
    $choicesHint.textContent = "m·ªçi th·ª© l√† n√∫t";
  }

  function renderHUD(){
    computeStats(false);
    const p = game.player;
    const d = p._derived || {atk:0, def:0, spd:0};
    const pills = [
      ["üë§", p.name],
      ["Lv", `${p.level}/${MAX_LV}`],
      ["EXP", `${p.exp}/${expNeeded(p.level)}`],
      ["üìç", p.location],
      ["üî•", game.world.heat],
      ["üïØÔ∏è", (p.souls||0)],
      ["‚ù§Ô∏è", `${p.stats.HP}/${p.max.HP}`],
      ["üåÄ", `${p.stats.MP}/${p.max.MP}`],
      ["ü™ô", p.gold],
    ];
    $hud.innerHTML = pills.map(([k,v])=>`<span class="pill">${k}: <b>${v}</b></span>`).join("");
  }

  function renderSidebar(){
    computeStats(false);
    const p = game.player;
    const r = raceById(p.raceId);
    const wk = weakness();
    const ultId = game.player.learnedSkills.find(id=>skillById(id)?.kind==="ultimate") || game.player.learnedSkills[0];
    const ult = skillById(ultId) || ULTIMATES[0];

    $lv.textContent = `Lv ${p.level}`;
    $xp.textContent = `EXP: ${p.exp}/${expNeeded(p.level)}`;
    $age.textContent = String(p.age);
    $gold.textContent = String(p.gold);
    if($souls) $souls.textContent = String(p.souls||0);
    $race.textContent = r.name;
    $raceBonus.textContent = r.perk;
        const prof = professionById(p.professionId);
    $job.textContent = `${prof.name}`;
    $jobBonus.textContent = `${prof.rarity} ‚Ä¢ ${prof.perk}`;
    $ultimate.textContent = ult.name;
    $ultimateDesc.textContent = ult.desc;
    $blessCount.textContent = String(p.blessings.length);
    $shopLevel.textContent = String(game.world.shop.level);
    $turn.textContent = String(game.turn);
    $ap.textContent = `H√†nh ƒë·ªông: ${game.actionInTurn}/10`;
    $stamina.textContent = `${p.stamina}/${p.maxStamina}`;
    $staminaHint.textContent = `M·ªói h√†nh ƒë·ªông t·ªën th·ªÉ l·ª±c ‚Ä¢ Rest ƒë·ªÉ h·ªìi.`;
    $mode.textContent = (game.mode.kind==="free") ? "Free" : game.mode.kind;
    $modeHint.textContent = game.mode.hint || "-";
    $statusLine.textContent = game.gameOver ? "game over" : (game.battle.active ? "ƒëang chi·∫øn ƒë·∫•u" : "ƒëang phi√™u l∆∞u");
  }

  function renderLog(){
    $log.innerHTML = "";
    game.log.slice(0, 16).forEach(x=>{
      const div = document.createElement("div");
      div.className = "logItem";
      div.innerHTML = `${x.html}<div class="t">${x.t}</div>`;
      $log.appendChild(div);
    });
  }

  function renderBattle(){
    if(!game.battle.active){ $battleUI.style.display = "none"; return; }
    $battleUI.style.display = "block";
    computeStats(false);
    const p = game.player;
    const e = game.battle.enemy;
    const pHpPct = Math.round((p.stats.HP/p.max.HP)*100);
    const eHpPct = Math.round((game.battle.enemyHP/game.battle.enemyMaxHP)*100);
    const shield = (game.battle.statuses.shield && game.battle.shieldHP>0) ? ` ‚Ä¢ Shield ${game.battle.shieldHP}` : "";
    const meter = (title, left, right, pct, cls="") => `
      <div class="meter battleAnimLayer">
        <div class="top"><span><b>${title}</b></span><span>${left} ‚Ä¢ ${right}</span></div>
        <div class="barWrap"><div class="barFill ${cls}" style="width:${pct}%"></div></div>
      </div>`;
    $battleBar.innerHTML =
      meter("Player", `HP ${p.stats.HP}/${p.max.HP}${shield}`, `MP ${p.stats.MP}/${p.max.MP}`, pHpPct, "good") +
      meter("Enemy", `${e.name} (Lv ${e.level})`, `HP ${game.battle.enemyHP}/${game.battle.enemyMaxHP}`, eHpPct, "bad");

    const turnBlocked = game.battle.turn !== "player";
    const slots = game.player.skillSlots.slice(0,4).map(id=> skillById(id)).filter(Boolean);
    while(slots.length < 4) slots.push(null);

    $skills.innerHTML = slots.map((sk, idx)=>{
      if(!sk) return `<button class="btn" disabled><b>${idx+1}) (Tr·ªëng)</b><br><span style="color:rgba(255,255,255,.65);font-size:12px;">Ch·ªçn trong Menu ‚Üí Skills</span></button>`;
      const cdLeft = game.battle.cds[sk.id] || 0;
      const mpCost = applySkillMpCost(sk);
      const disabled = turnBlocked || (cdLeft>0) || (p.stats.MP < mpCost);
      const cdTxt = cdLeft>0 ? `(CD ${cdLeft})` : "";
      return `<button class="btn ${disabled?"":"btnPrimary"}" ${disabled?"disabled":""} data-skill="${sk.id}"><b>${idx+1}) ${sk.name}</b> ${cdTxt}<br><span style="color:rgba(255,255,255,.65);font-size:12px;">${sk.kind==="ultimate"?"ULT ":""}MP -${mpCost} ‚Ä¢ ${sk.desc}</span></button>`;
    }).join("");

    $skills.querySelectorAll("button[data-skill]").forEach(btn=>{
      btn.addEventListener("click", ()=>{
        const id = btn.getAttribute("data-skill");
        if(!preAction(1, "d√πng skill")) return;
        countAction();
        castSkill(id);
        renderAll();
      });
    });

    const tail = game.battle.log.slice(-6).map(x=>x.replace(/<[^>]*>/g,"")).join(" | ");
    $help.textContent = `Battle: l∆∞·ª£t ${game.battle.turn==="player"?"B·∫°n":"Qu√°i"} ‚Ä¢ ${tail}`;
  }

  function normalizeMode(){
    // Fix tr·∫°ng th√°i "k·∫πt" sau khi ho√†n th√†nh dungeon/trial
    if(game.mode.kind === "dungeon" && !game.dungeon.active){
      game.mode = {kind:"free", hint:"T·ª± do phi√™u l∆∞u."};
      game.awaitingNext = null;
    }
    if(game.mode.kind === "trial" && !game.trial.active){
      game.mode = {kind:"free", hint:"T·ª± do phi√™u l∆∞u."};
      game.awaitingNext = null;
    }
    if(game.mode.kind === "forcedEvent" && !game.battle.active){
      game.mode = {kind:"free", hint:"T·ª± do phi√™u l∆∞u."};
    }
  }

  function renderAll(){ normalizeMode(); renderHUD(); renderSidebar(); renderLog(); renderBattle(); updateContextChoices(); }

  function renderMenu(){
    computeStats(false);
    const p = game.player;
    const npc = currentNPC();
    const wk = weakness();
    $menuChips.innerHTML = `
      <span class="tag">Lv ${p.level}/${MAX_LV}</span>
      <span class="tag">HP ${p.stats.HP}/${p.max.HP}</span>
      <span class="tag">MP ${p.stats.MP}/${p.max.MP}</span>
      <span class="tag">V√†ng ${p.gold}</span>
      <span class="tag">Th·ªÉ l·ª±c ${p.stamina}/${p.maxStamina}</span>
      <span class="tag">Tu·ªïi ${p.age}/${p.maxAge||100}</span>
      <span class="tag">NPC ${npc.name}</span>
      <span class="tag">Prof ${professionById(p.professionId).name}</span>
      <span class="tag">${wk?wk.name:"Nh∆∞·ª£c: (kh√¥ng)"}</span>`;
    $menuHint.textContent = "Ch·ªçn h√†nh ƒë·ªông. (L·ªánh ƒë√£ ƒë∆∞·ª£c thay b·∫±ng n√∫t)";
    $menuGrid.innerHTML = "";
    const items = [
      {t:"Battle", d:"ƒê√°nh qu√°i / c√≥ t·ªâ l·ªá g·∫∑p Boss Lv999.", fn: ()=>{ closeMenu(); doBattle(); }},
      {t:"Talk", d:"N√≥i chuy·ªán NPC (c√≥ th·ªÉ b·ªã l·ª´a -50% v√†ng).", fn: ()=>{ closeMenu(); openTalk(); }},
      {t:"Money", d:"Ki·∫øm ti·ªÅn (c√≥ t·ªâ l·ªá b·ªã qu·ªµt l∆∞∆°ng).", fn: ()=>{ closeMenu(); doMoney(); }},
      {t:"Shop", d:"Mua v·∫≠t ph·∫©m / v≈© kh√≠ / gi√°p / skill (kh√¥ng gi·ªõi h·∫°n level; shop level c√†ng cao h√†ng c√†ng x·ªãn).", fn: ()=>{ closeMenu(); openShop(); }},
      {t:"Gacha", d:"Quay h√≤m 100 v√†ng (c√≥ animation).", fn: ()=>{ closeMenu(); openGachaAndRoll(); }},
      {t:"Inventory", d:"T√∫i ƒë·ªì + d√πng thu·ªëc + trang b·ªã.", fn: ()=>{ closeMenu(); openInv(); }},
      {t:"Skills", d:"Ch·ªçn skill v√†o 4 √¥ skill.", fn: ()=>{ closeMenu(); openSkills(); }},
      {t:"Rest", d:"Ngh·ªâ ƒë·ªÉ h·ªìi th·ªÉ l·ª±c + 25% HP/MP.", fn: ()=>{ closeMenu(); doRest(); }},
      {t:"B·ªã ƒë·ªông", d:"Xem b·ªã ƒë·ªông + nh∆∞·ª£c.", fn: ()=>{ closeMenu(); openPassives(); }},
      {t:"Ch·ª©c nghi·ªáp", d:"Xem ch·ª©c nghi·ªáp (bonus).", fn: ()=>{ closeMenu(); openProfession(); }},
      {t:"Save", d:"L∆∞u game (manual).", fn: ()=>{ closeMenu(); saveGame(); }},
      {t:"Load", d:"Load game ƒë√£ l∆∞u.", fn: ()=>{ closeMenu(); loadGame(); }},
      {t:"Forge", d:"R√®n ƒë·ªì +1..+100 (1/10^n).", fn: ()=>{ closeMenu(); openForge(); }},
      {t:"Dungeon", d:"V√†o dungeon (20% S·ª© gi·∫£ drop ph∆∞·ªõc).", fn: ()=>{ closeMenu(); startDungeon(); }},
      {t:"Trial", d:"Trial g·ªôp: Trial Th·∫ßn (50 t·∫ßng) + Trial Anh H√πng (100 t·∫ßng).", fn: ()=>{ closeMenu(); openTrial(); }},      {t:"Gamble", d:"", fn: ()=>{ closeMenu(); openGamble(); }},
      {t:"Next", d:"ƒêi t·∫ßng ti·∫øp theo (dungeon/trial).", fn: ()=>{ closeMenu(); doNext(); }},
      {t:"Travel", d:"Ch·ªçn ƒë·ªãa ƒëi·ªÉm ch·ªâ ƒë·ªãnh.", fn: ()=>{ closeMenu(); openTravel(); }},
    ];
    for(const it of items){
      const card = document.createElement("div");
      card.className = "menuCard";
      card.innerHTML = `<div class="t">${it.t}</div><div class="d">${it.d}</div>`;
      card.addEventListener("click", it.fn);
      $menuGrid.appendChild(card);
    }
  }

  function rollStatsBase(){
    const roll = (base, spread) => base + randInt(0, spread);
    return { HP: roll(18, 14), MP: roll(6, 8), STR: roll(4, 10), DEX: roll(4, 10), INT: roll(4, 10), CHA: roll(4, 10), LUK: roll(3, 12), DEF: roll(2, 8) };
  }
  function rollUltimate(){ return pick(ULTIMATES); }

  function rerollAll(){
    const names = ["Aster","Khai","Nami","Rin","Sora","Yuki","Minh","Tuy·∫øt","H·∫°","Khoa","Vy","Long"];
    game.player.name = pick(names) + (Math.random()<0.35 ? " " + pick(["Fey","Noir","Linh","V√¢n","Khang","Tr√∫c"]) : "");
    game.player.age = randInt(16, 28);
    game.turn = 0; game.actionInTurn = 0;
    game.player.level = 1; game.player.exp = 0; game.player.gold = 120;
    game.player.maxStamina = 100; game.player.stamina = 100;
    game.player.location = "Th√†nh ph·ªë ƒê·∫°o T·∫∑c";
    game.player.raceId = rollRaceWeighted().id;
    game.player.maxAge = raceById(game.player.raceId).maxAge || 100;
    game.player.raceRerollsLeft = 3;
    game.player.learnedSkills = [];
    game.player.skillSlots = [null,null,null,null];
    game.player.passives = [];
    game.player.weaknessId = pick(WEAKNESSES).id;
    game.player.professionId = rollProfession().id;
    const ult = rollUltimate(); learnSkill(ult.id);
    const pool = ACTIVE_SKILLS.filter(s=>s.kind==="active");
    for(let i=0;i<3;i++) learnSkill(pick(pool).id);
    learnPassive(pick(PASSIVES).id);
    game.player.base = rollStatsBase();
    game.player.baseStart = {...game.player.base};
    game.player.forcedLaborTurns = 0;
    game.player.kidneyDebuff = false;
    game.player.stats = {...game.player.base};
    game.player.blessings = [];
    game.player.inv = [
      {kind:"stack", id:"potion", qty:2},
      {kind:"stack", id:"ether", qty:1},
      {kind:"stack", id:"ore", qty:4},
      {kind:"gear", uid:uid(), id:"wooden_sword", enh:0},
      {kind:"gear", uid:uid(), id:"cloth", enh:0},
    ];
    game.player.equipped = {weaponUid:null, armorUid:null};
    game.trial.progress = {};
    game.world.shop.level = 0; game.world.shop.lastRefreshTurn = -1;
    ensureNPCs(); rollStory(); syncCreateUI();
  }
  function rerollRace(){
    if(game.player.raceRerollsLeft <= 0) return;
    game.player.raceId = rollRaceWeighted().id;
    game.player.maxAge = raceById(game.player.raceId).maxAge || 100;
    game.player.raceRerollsLeft -= 1;
    syncCreateUI();
  }
  function syncCreateUI(){
    ensureNPCs();
    const npc = currentNPC();
    const r = raceById(game.player.raceId);
    const wk = weakness();
    const ultId = game.player.learnedSkills.find(id=>skillById(id)?.kind==="ultimate") || game.player.learnedSkills[0];
    const u = skillById(ultId) || ULTIMATES[0];
    const bs = game.player.base;
    $nameInput.value = game.player.name;
    $tagAge.textContent = `Tu·ªïi: ${game.player.age}`;
    $tagLocation.textContent = `N∆°i: ${game.player.location}`;
    $tagNPC.textContent = `NPC: ${npc.name} (${npc.role})`;
    $raceTag.textContent = `${r.name}`;
    $racePerk.textContent = r.perk;
    $btnRerollRace.textContent = `Reroll t·ªôc (${game.player.raceRerollsLeft})`;
    $btnRerollRace.disabled = game.player.raceRerollsLeft <= 0;
        const prof = professionById(game.player.professionId);
    $jobTag.textContent = `${prof.name} (${prof.rarity})`;
    $jobPerk.textContent = `${prof.perk} ‚Ä¢ B·ªã ƒë·ªông: ${game.player.passives.length} ‚Ä¢ ${wk?("Nh∆∞·ª£c: "+wk.name):"Nh∆∞·ª£c: (kh√¥ng)"}`;
    $ultTag.textContent = u.name;
    $ultPerk.textContent = u.desc;
    $stHP.textContent = bs.HP; $stMP.textContent = bs.MP; $stSTR.textContent = bs.STR; $stDEX.textContent = bs.DEX;
    $stINT.textContent = bs.INT; $stCHA.textContent = bs.CHA; $stLUK.textContent = bs.LUK; $stDEF.textContent = bs.DEF;
    const slotNames = game.player.skillSlots.map(id=> skillById(id)?.name || "(tr·ªëng)").join(" ‚Ä¢ ");
    $bonusTags.innerHTML = `
      <span class="tag">4 √¥ skill: ${slotNames}</span>
      <span class="tag">Ult: ${u.name} (1 l·∫ßn t·∫°o)</span>
      <span class="tag">Boss 999: lu√¥n cu·ªìng n·ªô (1 l·∫ßn)</span>
      <span class="tag">Dungeon: 20% S·ª© gi·∫£ drop ph∆∞·ªõc</span>
      <span class="tag">Trial: 10 t·∫ßng/1 ph∆∞·ªõc</span>
      <span class="tag">Forge: +1..+100</span>`;
  }
  function startGame(){
    const nm = ($nameInput.value||"").trim();
    if(nm) game.player.name = nm.slice(0,24);
    game.started = true;
    ensureTensuraState();
    learnSkill("basic_attack");
    $overlayCreate.style.display = "none";
    refreshShopStock(true);
    computeStats(true);
    const s = game.story;
    pushStory(`=== C·ªêT TRUY·ªÜN (Random) ===\n${s.prologue}\nM·ª•c ti√™u: ${s.goal}\nK·∫ª th√π: ${s.nemesis}\nB√≠ m·∫≠t: ${s.twist}\n\nM·ªçi th·ª© ƒë√£ ƒë∆∞·ª£c thay b·∫±ng <b>n√∫t</b>.\nB·∫•m n√∫t Menu g√≥c ph·∫£i d∆∞·ªõi ƒë·ªÉ ch∆°i.`);
    addLog(`B·∫Øt ƒë·∫ßu game v·ªõi <b>${game.player.name}</b>.`);
    renderAll();
  }

  $btnRerollAll.addEventListener("click", ()=> rerollAll());
  $btnRerollRace.addEventListener("click", ()=> rerollRace());
  $btnStart.addEventListener("click", ()=> startGame());

  $btnCloseShop.addEventListener("click", ()=> $overlayShop.style.display="none");
  $btnTipShop.addEventListener("click", ()=> tipShop());

  $btnCloseForge.addEventListener("click", ()=> $overlayForge.style.display="none");
  $btnForgeRefresh.addEventListener("click", ()=> { renderForgeList(); renderForgeDetail(); });

  $btnCloseTrial.addEventListener("click", ()=> $overlayTrial.style.display="none");
  if($trialModeSelect) $trialModeSelect.addEventListener("change", ()=> renderTrialPanel());
  $trialSelect.addEventListener("change", ()=> renderTrialPanel());
  $btnStartTrial.addEventListener("click", ()=> {
    $overlayTrial.style.display="none";
    const mode = ($trialModeSelect && $trialModeSelect.value) ? $trialModeSelect.value : (game.trialUI?.mode || "god");
    if(mode==="hero") startHeroTrial();
    else startOrResumeTrial($trialSelect.value);
  });

  $btnCloseGacha.addEventListener("click", ()=> $overlayGacha.style.display="none");
    $btnGacha1?.addEventListener("click", ()=> openGachaMulti(1));
  $btnGacha10?.addEventListener("click", ()=> openGachaMulti(10));
$btnGachaOk.addEventListener("click", ()=> $overlayGacha.style.display="none");

  $btnMenu.addEventListener("click", ()=> openMenu());
  $btnCloseMenu.addEventListener("click", ()=> closeMenu());
  $overlayMenu.addEventListener("click", (e)=>{ if(e.target === $overlayMenu) closeMenu(); });

  $btnCloseTalk.addEventListener("click", ()=> closeTalk());
  $btnTalkSend.addEventListener("click", ()=> doTalkSend());
  $talkInput.addEventListener("keydown", (e)=>{ if(e.key==="Enter") doTalkSend(); });

  $btnCloseSkills.addEventListener("click", ()=> $overlaySkills.style.display="none");
  document.getElementById("btnClosePassives").addEventListener("click", ()=> $overlayPassives.style.display="none");
  document.getElementById("btnCloseProfession").addEventListener("click", ()=> $overlayProfession.style.display="none");
  $btnCloseInv.addEventListener("click", ()=> closeInv());

  window.addEventListener("keydown", (e)=>{
    if(game.battle.active && ["1","2","3","4"].includes(e.key)){
      const idx = parseInt(e.key,10)-1;
      const id = game.player.skillSlots[idx];
      if(id){ if(!preAction(1, "d√πng skill")) return; countAction(); castSkill(id); renderAll(); }
    }
    if(e.key==="Escape"){
      if($overlayMenu.style.display==="flex") closeMenu();
      if($overlayTalk.style.display==="flex") closeTalk();
      if($overlaySkills.style.display==="flex") $overlaySkills.style.display="none";
      if($overlayInv.style.display==="flex") closeInv();
    }
  });

  ensureNPCs();
  rerollAll();
  $overlayCreate.style.display = "flex";
  $help.textContent = "M·ªçi th·ª© l√† n√∫t. B·∫•m Menu g√≥c ph·∫£i d∆∞·ªõi. Trong battle d√πng 4 n√∫t skill (ph√≠m 1-4).";
  renderAll();
});

</script>

  <!-- Floating Menu Button -->
  <button class="menuBtn" id="btnMenu">‚ò∞ Menu</button>

  <!-- Menu Overlay -->
  <div class="overlay" id="overlayMenu">
    <div class="modal" style="width:min(720px,100%);">
      <div class="modalTop">
        <div>
          <h2>Menu</h2>
          <p id="menuHint">Ch·ªçn h√†nh ƒë·ªông.</p>
          <div class="tagList" id="menuChips"></div>
        </div>
        <div style="display:flex; gap:10px;">
          <button class="btn btnPrimary" id="btnCloseMenu">ƒê√≥ng</button>
        </div>
      </div>
      <div class="modalBody" style="grid-template-columns: 1fr;">
        <div class="field">
          <label>H√†nh ƒë·ªông</label>
          <div class="menuGrid" id="menuGrid"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Talk Overlay -->
  <div class="overlay" id="overlayTalk">
    <div class="modal" style="width:min(680px,100%);">
      <div class="modalTop">
        <div>
          <h2>N√≥i chuy·ªán (Talk)</h2>
          <p>NPC ph·∫£n h·ªìi theo t√≠nh c√°ch random. C√≥ kh·∫£ nƒÉng b·ªã l·ª´a (m·∫•t 50% v√†ng).</p>
        </div>
        <div style="display:flex; gap:10px;">
          <button class="btn" id="btnCloseTalk">ƒê√≥ng</button>
          <button class="btn btnPrimary" id="btnTalkSend">G·ª≠i</button>
        </div>
      </div>
      <div class="modalBody" style="grid-template-columns: 1fr;">
        <div class="field">
          <label>Nh·∫≠p l·ªùi tho·∫°i</label>
          <input id="talkInput" placeholder="V√≠ d·ª•: Xin ch√†o! B·∫°n bi·∫øt dungeon ·ªü ƒë√¢u kh√¥ng?" />
          <div class="mini" style="margin-top:10px;">Enter ƒë·ªÉ g·ª≠i ‚Ä¢ Esc ƒë·ªÉ ƒë√≥ng.</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Skills Overlay -->
  <div class="overlay" id="overlaySkills">
    <div class="modal">
      <div class="modalTop">
        <div>
          <h2>Qu·∫£n l√Ω Skill (4 √¥)</h2>
          <p>Ch·ªçn k·ªπ nƒÉng b·∫°n ƒë√£ h·ªçc v√†o 4 √¥ skill. Kh√¥ng cho ph√©p tr√πng skill gi·ªØa c√°c √¥.</p>
        </div>
        <div style="display:flex; gap:10px;">
          <button class="btn btnPrimary" id="btnCloseSkills">ƒê√≥ng</button>
        </div>
      </div>
      <div class="modalBody" style="grid-template-columns: 1fr 1fr;">
        <div class="field">
          <label>√î k·ªπ nƒÉng</label>
          <div class="list" id="skillSlotsWrap"></div>
          <div class="mini">Trong battle c√≥ th·ªÉ b·∫•m ph√≠m 1-4.</div>
        </div>
        <div class="field">
          <label>Danh s√°ch ƒë√£ h·ªçc</label>
          <div class="list" id="skillListWrap"></div>
        </div>
      </div>
    </div>
  </div>


  <!-- Passives Overlay -->
  <div class="overlay" id="overlayPassives">
    <div class="modal">
      <div class="modalTop">
        <div>
          <h2>B·ªã ƒë·ªông & Nh∆∞·ª£c</h2>
          <p>Danh s√°ch b·ªã ƒë·ªông hi·ªán c√≥ (mua trong shop / random khi t·∫°o).</p>
        </div>
        <div style="display:flex; gap:10px;">
          <button class="btn btnPrimary" id="btnClosePassives">ƒê√≥ng</button>
        </div>
      </div>
      <div class="modalBody" style="grid-template-columns:1fr;">
        <div class="field">
          <label>B·ªã ƒë·ªông ƒëang s·ªü h·ªØu</label>
          <div class="list" id="passiveListWrap"></div>
        </div>
        <div class="field">
          <label>Nh∆∞·ª£c</label>
          <div class="list" id="weaknessWrap"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Profession Overlay -->
  <div class="overlay" id="overlayProfession">
    <div class="modal">
      <div class="modalTop">
        <div>
          <h2>Ch·ª©c nghi·ªáp</h2>
          <p>Ch·ª©c nghi·ªáp random khi t·∫°o nh√¢n v·∫≠t v√† kh√≥a trong qu√° tr√¨nh ch∆°i.</p>
        </div>
        <div style="display:flex; gap:10px;">
          <button class="btn btnPrimary" id="btnCloseProfession">ƒê√≥ng</button>
        </div>
      </div>
      <div class="modalBody" style="grid-template-columns:1fr;">
        <div class="field">
          <label>Th√¥ng tin</label>
          <div class="list" id="professionWrap"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Battle Scene (Cinematic) -->
  <div class="cinematic" id="cinematic">
    <div class="cinBox">
      <div class="cinTitle" id="cinTitle">BATTLE</div>
      <div class="cinSub" id="cinSub">‚Äî</div>
    </div>
  </div>

  <!-- Inventory Overlay -->
  <div class="overlay" id="overlayInv">
    <div class="modal">
      <div class="modalTop">
        <div>
          <h2>T√∫i ƒë·ªì</h2>
          <p>D√πng thu·ªëc / trang b·ªã nhanh b·∫±ng n√∫t.</p>
        </div>
        <div style="display:flex; gap:10px;">
          <button class="btn btnPrimary" id="btnCloseInv">ƒê√≥ng</button>
        </div>
      </div>
      <div class="modalBody" style="grid-template-columns: 1fr;">
        <div class="field" id="invBody"></div>
      </div>
    </div>
  </div>

</body>
</html>
  /** ===================== Empire & Party (Tensura) ===================== **/
  function ensureEmpire(){
    game.world.empire ??= {level:1, citizens:5, fame:0, buildings:{hall:1, housing:0, market:0, barracks:0, lab:0}};
    game.world.lastDefeated ??= null;
    game.player.party ??= [];
    for(const a of game.player.party){
      a.level ??= 1;
      a.maxHp ??= Math.max(10, a.level*10);
      a.hp = clamp(a.hp ?? a.maxHp, 0, a.maxHp);
      a.atk ??= Math.max(2, Math.round(a.level*2.2));
      a.def ??= Math.max(1, Math.round(a.level*1.2));
    }
  }

  function partyCap(){
    ensureEmpire();
    const b = game.world.empire.buildings || {};
    return 1 + (b.barracks||0);
  }

  function openParty(){
    if($overlayMenu?.style?.display==='flex') $overlayMenu.style.display='none';
    ensureEmpire();
    const cap = partyCap();
    const list = game.player.party || [];
    $partySummary.textContent = `Slot: ${list.length}/${cap} ‚Ä¢ ƒê·ªìng ƒë·ªôi t·ª± ƒë√°nh sau l∆∞·ª£t b·∫°n.`;
    $partyList.innerHTML = list.length ? list.map((a, i)=>`
      <div class="box" style="padding:12px;">
        <div style="display:flex; justify-content:space-between; gap:10px; align-items:center;">
          <div>
            <div><b>${a.name}</b> (Lv ${a.level})</div>
            <div class="mini">HP ${a.hp}/${a.maxHp} ‚Ä¢ ATK ${a.atk} ‚Ä¢ DEF ${a.def}</div>
          </div>
          <button class="btn" data-dismiss="${i}">Lo·∫°i</button>
        </div>
      </div>
    `).join("") : `<div class="mini">Ch∆∞a c√≥ ƒë·ªìng ƒë·ªôi. H√£y <b>ƒë√°nh b·∫°i qu√°i</b> r·ªìi b·∫•m <b>Thu ph·ª•c</b> ƒë·ªÉ nh·∫≠n.</div>`;
    $partyList.querySelectorAll("button[data-dismiss]").forEach(btn=>{
      btn.addEventListener("click", ()=>{
        const i = Number(btn.getAttribute("data-dismiss"));
        if(Number.isFinite(i)){
          const gone = game.player.party.splice(i,1)[0];
          addLog(`ƒê√£ lo·∫°i ƒë·ªìng ƒë·ªôi: <b>${gone?.name||"?"}</b>.`);
          openParty();
          renderAll();
        }
      });
    });
    showOverlay("overlayParty");
  }

  function openEmpire(){
    if($overlayMenu?.style?.display==='flex') $overlayMenu.style.display='none';
    if(game.player.location !== "Tensura"){
      pushStory("ƒê·∫ø ch·∫ø ch·ªâ c√≥ th·ªÉ qu·∫£n l√Ω ·ªü <b>Tensura</b>.");
      addLog("ƒê·∫ø ch·∫ø: kh√¥ng ·ªü Tensura.");
      renderAll();
      return;
    }
    ensureEmpire();
    renderEmpire();
    showOverlay("overlayEmpire");
  }

  function empireCost(buildKey){
    const e = game.world.empire;
    const cur = e.buildings[buildKey] || 0;
    const next = cur + 1;
    const gold = 80 * next * next + 120 * (e.level||1);
    const souls = 2 * next + (buildKey==="hall" ? 5 : 0);
    return {gold, souls, next};
  }

  function upgradeBuilding(buildKey){
    ensureEmpire();
    const e = game.world.empire;
    const {gold, souls, next} = empireCost(buildKey);
    if(game.player.gold < gold){ addLog("Kh√¥ng ƒë·ªß v√†ng."); return; }
    if((game.player.souls||0) < souls){ addLog("Kh√¥ng ƒë·ªß Souls."); return; }
    game.player.gold -= gold;
    game.player.souls -= souls;
    e.buildings[buildKey] = next;
    if(buildKey==="hall") e.level += 1;
    if(buildKey==="housing") e.citizens += 5;
    if(buildKey==="market") e.fame += 1;
    addLog(`üèóÔ∏è N√¢ng c·∫•p ${buildKey} l√™n Lv ${next}.`);
    renderEmpire();
    renderAll();
  }

  function collectTax(){
    ensureEmpire();
    const e = game.world.empire;
    const market = e.buildings.market || 0;
    const citizens = e.citizens || 0;
    const hall = e.buildings.hall || 1;
    const income = Math.max(0, Math.floor((citizens * (1 + market*0.25)) + hall*25));
    game.player.gold += income;
    addLog(`üè¶ Thu thu·∫ø ƒë·∫ø ch·∫ø: <b>+${income}</b> v√†ng.`);
    pushStory(`üè¶ B·∫°n thu thu·∫ø t·ª´ ƒë·∫ø ch·∫ø: <b>+${income}</b> v√†ng.`);
    renderEmpire();
    renderAll();
  }

  function renderEmpire(){
    ensureEmpire();
    const e = game.world.empire;
    const b = e.buildings;
    $empireSummary.innerHTML = `ƒê·∫ø ch·∫ø Lv <b>${e.level}</b> ‚Ä¢ D√¢n <b>${e.citizens}</b> ‚Ä¢ Danh ti·∫øng <b>${e.fame}</b><br>Slot ƒë·ªìng ƒë·ªôi: <b>${(game.player.party||[]).length}/${partyCap()}</b>`;
    const rows = [
      ["hall","Town Hall", "TƒÉng Lv ƒë·∫ø ch·∫ø, m·ªü kh√≥a ti·∫øn h√≥a cao h∆°n."],
      ["housing","Housing", "TƒÉng d√¢n s·ªë (tƒÉng thu·∫ø)."],
      ["market","Market", "TƒÉng thu·∫ø + danh ti·∫øng."],
      ["barracks","Barracks", "M·ªói c·∫•p +1 slot ƒë·ªìng ƒë·ªôi."],
      ["lab","Lab", "TƒÉng c∆° h·ªôi nh·∫≠n passive hi·∫øm t·ª´ Predator."]
    ];
    $empireBuildings.innerHTML = rows.map(([k,label,desc])=>{
      const cur = b[k]||0;
      const {gold, souls, next} = empireCost(k);
      return `<div style="margin-bottom:10px;">
        <div><b>${label}</b> (Lv ${cur})</div>
        <div class="mini">${desc}</div>
        <div class="row" style="margin-top:6px; gap:10px; flex-wrap:wrap;">
          <button class="btn btnPrimary" data-up="${k}">N√¢ng l√™n Lv ${next}</button>
          <span class="tag">Cost: ${gold} v√†ng + ${souls} Souls</span>
        </div>
      </div>`;
    }).join("");
    $empireBuildings.querySelectorAll("button[data-up]").forEach(btn=>{
      btn.addEventListener("click", ()=> upgradeBuilding(btn.getAttribute("data-up")));
    });
  }

  function openRecruit(){
    if($overlayMenu?.style?.display==='flex') $overlayMenu.style.display='none';
    ensureEmpire();
    const last = game.world.lastDefeated;
    if(!last){ pushStory("Ch∆∞a c√≥ qu√°i v·ª´a b·ªã ƒë√°nh b·∫°i ƒë·ªÉ thu ph·ª•c."); addLog("Thu ph·ª•c: kh√¥ng c√≥ m·ª•c ti√™u."); renderAll(); return; }
    $recruitResult.textContent = "";
    $recruitName.value = "";
    $recruitInfo.innerHTML = `M·ª•c ti√™u: <b>${last.name}</b> (Lv ${last.level}) ‚Ä¢ Cost: <b>50 v√†ng</b> + <b>5 Souls</b>.`;
    showOverlay("overlayRecruit");
  }

  function recruitConfirm(){
    ensureEmpire();
    const cap = partyCap();
    if((game.player.party||[]).length >= cap){ $recruitResult.textContent = "H·∫øt slot ƒë·ªìng ƒë·ªôi. N√¢ng Barracks."; return; }
    const last = game.world.lastDefeated;
    if(!last){ $recruitResult.textContent = "Kh√¥ng c√≥ m·ª•c ti√™u."; return; }
    const nm = String($recruitName.value||"").trim();
    if(!nm){ $recruitResult.textContent = "H√£y nh·∫≠p t√™n."; return; }
    if(game.player.gold < 50){ $recruitResult.textContent = "Kh√¥ng ƒë·ªß v√†ng."; return; }
    if((game.player.souls||0) < 5){ $recruitResult.textContent = "Kh√¥ng ƒë·ªß Souls."; return; }
    if(/ma v∆∞∆°ng|anh h√πng/i.test(last.name)){ $recruitResult.textContent = "Kh√¥ng th·ªÉ thu ph·ª•c m·ª•c ti√™u n√†y."; return; }

    game.player.gold -= 50;
    game.player.souls -= 5;

    const level = Math.max(1, last.level);
    const ally = {name:nm, species:last.name, level, maxHp:Math.max(20, level*10), hp:Math.max(20, level*10), atk:Math.max(3, Math.round(level*2.2)), def:Math.max(1, Math.round(level*1.2))};
    game.player.party.push(ally);
    game.world.lastDefeated = null;
    $recruitResult.innerHTML = `‚úÖ Thu ph·ª•c th√†nh c√¥ng: <b>${nm}</b>!`;
    addLog(`ü§ù Thu ph·ª•c ƒë·ªìng ƒë·ªôi: <b>${nm}</b> (Lv ${level}).`);
    pushStory(`ü§ù B·∫°n ƒë√£ ƒë·∫∑t t√™n v√† thu ph·ª•c <b>${nm}</b> l√†m ƒë·ªìng ƒë·ªôi!`);
    renderAll();
  }

  $btnCloseEmpire?.addEventListener("click", ()=> $overlayEmpire.style.display="none");
  $btnEmpireCollect?.addEventListener("click", ()=> collectTax());
  $btnOpenParty?.addEventListener("click", ()=> openParty());
  $btnCloseParty?.addEventListener("click", ()=> $overlayParty.style.display="none");
  $btnCloseRecruit?.addEventListener("click", ()=> $overlayRecruit.style.display="none");
  $btnRecruitConfirm?.addEventListener("click", ()=> recruitConfirm());



